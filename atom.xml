<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nicosq.github.io</id>
    <title>nicosq_Blog</title>
    <updated>2020-07-27T08:43:31.553Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nicosq.github.io"/>
    <link rel="self" href="https://nicosq.github.io/atom.xml"/>
    <subtitle>分享我的所学</subtitle>
    <logo>https://nicosq.github.io/images/avatar.png</logo>
    <icon>https://nicosq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, nicosq_Blog</rights>
    <entry>
        <title type="html"><![CDATA[个人建模渲染练习【1】]]></title>
        <id>https://nicosq.github.io/post/ge-ren-jian-mo-xuan-ran-lian-xi-ji-lu-1/</id>
        <link href="https://nicosq.github.io/post/ge-ren-jian-mo-xuan-ran-lian-xi-ji-lu-1/">
        </link>
        <updated>2020-07-27T08:34:46.000Z</updated>
        <content type="html"><![CDATA[<p>最近正在学习Blender，整理一下以前的一些建模和渲染练习（部分模型素材来自网上）。</p>
<p>使用软件：Maya Blender</p>
<hr>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh5lrlj6odj30zk0k0q5e.jpg" alt="Maya麦当劳1.jpg"  />
<blockquote>
<p><strong>《麦当劳》 Maya</strong></p>
</blockquote>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh5luksetbj31hc0u07bn.jpg" alt="Maya挖掘机2.jpg"  />
<figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh5lv9c7u0j31hc0u0tez.jpg" alt="Maya挖掘机1.jpg" loading="lazy"></figure>
<blockquote>
<p><strong>《挖掘机》 Maya</strong></p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh5lw1pwc6j30zk0k0n1z.jpg" alt="Maya卧室1.jpg" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh5lwct1ipj30zk0k00xg.jpg" alt="Maya卧室2.jpg" loading="lazy"></figure>
<blockquote>
<p><strong>《卧室》 Maya</strong></p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh5m0x4siaj31hc0u01ky.jpg" alt="Blender笔筒渲染.png" loading="lazy"></figure>
<blockquote>
<p><strong>《笔筒》 Blender(Eevee渲染)</strong></p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh5m3ti4hkj31hc0u07wh.jpg" alt="Blender水槽渲染.png" loading="lazy"></figure>
<blockquote>
<p><strong>《水槽》 Blender(Eevee渲染)</strong></p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh5m4scni9j31hc0u0e82.jpg" alt="Blender石中剑渲染.png" loading="lazy"></figure>
<blockquote>
<p><strong>《石中剑》 Blender(Eevee渲染)</strong></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity大片草地渲染5（Demo展示）]]></title>
        <id>https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-5demo-zhan-shi/</id>
        <link href="https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-5demo-zhan-shi/">
        </link>
        <updated>2020-07-27T02:37:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="视频展示">视频展示</h2>
<p>结合《Unity大片草地渲染 1- 4》系列文章的Demo展示。</p>
<p>B站ID：NicoSQ</p>
<p>B站个人空间：<a href="https://space.bilibili.com/42345791">https://space.bilibili.com/42345791</a></p>
<p>欢迎关注我的B站。</p>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=201480631&bvid=BV1fh411o764&cid=216960096&page=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no"></iframe>
</div>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity实现三种云层渲染效果]]></title>
        <id>https://nicosq.github.io/post/unity-shi-xian-san-chong-yun-ceng-xuan-ran-xiao-guo/</id>
        <link href="https://nicosq.github.io/post/unity-shi-xian-san-chong-yun-ceng-xuan-ran-xiao-guo/">
        </link>
        <updated>2020-07-27T02:27:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>云层的渲染也是游戏开发中的常见问题了。之前有次项目计划想要实现大片云层渲染的效果，上网查阅了很多资料。这次在这篇文章中简单介绍一下三种之前学习过的利用Unity生成云的效果。基本上是按照原作者的思路来实现的，原文的制作方法也讲得很详细，所以在正文部分<strong>只贴出一些个人理解的笔记部分，在最后的参考资料会贴出原文的链接供大家深入学习和参考</strong>。</p>
<hr>
<h2 id="导航图">导航图</h2>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4e251g02j311805r74r.jpg" alt="1_10.png" style="zoom:80%;" />
<hr>
<h2 id="正文">正文</h2>
<p>第一种是基于是视觉映射原理实现云层效果。</p>
<p>在计算机图形学中视差映射是法线映射的一个增强版本，它不止改变了光照的作用方式，还在平坦的多边形上创建了3D细节的假象。不会生成任何额外的图元。<strong>事实上，这个方法只偏移了用来获取颜色和高度值的纹理坐标</strong>。</p>
<p>要实现视差映射<strong>通常需要一张高度贴图</strong>。高度图中的每个像素包含了表面高度的信息。纹理中的高度会被转化成对应的点沉入表面多少的信息。这种情况你得把高度图中读出来的值反过来用。通常视差映射会把高度图中的值当深度来用，<strong>黑色(0)代表和表面齐平的高度，白色(1)代表最深的凹陷值</strong>。</p>
<p><strong>所有的视觉映射计算都是在切空间进行的</strong>。想要实现偏移纹理坐标也很简单，<strong>我们首先得到切空间下的视角方向（向量 V），因为切空间是沿着纹理坐标方向建立的，所以向量 V 的 X 和 Y 分量就可以直接不加换算的用作纹理坐标的偏移量</strong>。</p>
<p>下面是切线空间（TBN）下的示意图。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh46togsvrj30ir0hy0tc.jpg" alt="1_1.png" style="zoom:50%;" />
<p>但是通常由普通的偏移得到的效果都不是很好，而视觉映射也有很多改进版本，视差遮蔽映射( POM )就是其中一个。<strong>本质上还是纹理坐标的偏移，但是通过插值采样的方法来得到更加准确的结果</strong>。</p>
<p>下面是采样示意图（<strong>T3是我们最终采用的纹理坐标点</strong>）。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh47a4ng3yj30kt0ibq3j.jpg" alt="1_3.png" style="zoom:50%;" />
<p>得到最终的效果图。</p>
<blockquote>
<p><strong>这个云层并没有实际上对网格顶点做偏移，所以侧面看的时候依然是平面，适用于一些特定角度下的远距离或者正下方的云海景观</strong>。</p>
</blockquote>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh46vwslbtj30sn0fxam6.jpg" alt="1_2.png" style="zoom:50%;" />
<p>不同于平面的云层，我们经常还能在游戏中看到效果很好的体积云效果。下面介绍的第二种方法就是<strong>基于粒子 + 序列图 + MatCap实现的体积云效果</strong>。</p>
<p>这个方法的涉及到的知识点有很多。<strong>原理就是利用粒子+序列图来实现体积云的主体部分，再利用MatCap技术对场景中的光照信息进行采样来实现体积云的光照变化</strong>。</p>
<blockquote>
<p><strong>MatCap技术的原理并不复杂，就是使用一张中间为球面的图片作为不同法线方向的光照颜色，然后将这些颜色根据模型的法线信息渲染到相应位置。通常具体的实现方法就是将模型的法线转到视觉空间下（注意转为视觉空间下法线的范围为 -1~1，而 UV 映射的范围为 0~1），再对MatCap贴图进行采样</strong>。</p>
</blockquote>
<p>关于粒子的设置和shader代码可以参考原文链接，讲得十分详细，这里直接来看看效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh48zkvv8yj30sm0gbjxj.jpg" alt="1_4.png" style="zoom: 50%;" />
<p>最后一种方法也是生成体积云，不过这次我们使用的工具是 ShaderGraph，需要使用到Unity的高清渲染管线（HDRP）。</p>
<p>这个方法首先需要我们在建模软件创建一个顶点数量足够多的网格（当然也可以用程序生成）。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh49acoa8sj30bj0bbt9n.jpg" alt="1_5.png" style="zoom:80%;" />
<p>方法的原理也很简单，<strong>我们首先利用ShaderGraph自带的节点分别生成底层的噪波图（Base Noise）和控制细节的噪波图（Detail Noise），这两张噪波图相加得到的最终的噪波图（Final NoiseMap）控制我们云层的复杂程度</strong>。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh49izpwxmj31do0iwq9g.jpg" alt="1_6.png" style="zoom: 50%;" />
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh49jxaa6tj316u0d5di6.jpg" alt="1_7.png" style="zoom: 67%;" />
<p><strong>这个方法的本质上是对模型顶点的偏移。用模型空间下的物体法线与噪波图层相乘，得到法线偏移信息，再与模型空间下的顶点进行相加，进行法线方向上的偏移</strong>。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4drhd4r8j30sh0hf75d.jpg" alt="1_8.png" style="zoom:67%;" />
<p>关于云的着色实现的方法很简单，用Lerp函数对生成的噪波图插值计算，此外还可以添加Fresnel效果。</p>
<p>下面的最终的效果图。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4dyle7lyj30ws0ggtby.jpg" alt="1_9.png" style="zoom: 67%;" />
<h2 id="视频展示">视频展示</h2>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=668876600&bvid=BV1xa4y1a7qL&cid=216965971&page=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no"></iframe>
</div>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>Unity Shader基于视差映射的云海效果</p>
<p><a href="https://zhuanlan.zhihu.com/p/83355147">https://zhuanlan.zhihu.com/p/83355147</a></p>
</li>
<li>
<p>GLSL中的视觉遮蔽映射（Parrallax Occlusion Mapping in GLSL）</p>
<p><a href="https://segmentfault.com/a/1190000003920502">https://segmentfault.com/a/1190000003920502</a></p>
</li>
<li>
<p>笔记三十一 —— 使用粒子序列图实现体积云</p>
<p><a href="https://zhuanlan.zhihu.com/p/89484732">https://zhuanlan.zhihu.com/p/89484732</a></p>
</li>
<li>
<p>Ultimate Clouds with Shader Graph in Unity 2019, Made Easy [Tutorial]</p>
<p><a href="https://www.youtube.com/watch?v=Y7r5n5TsX_E">https://www.youtube.com/watch?v=Y7r5n5TsX_E</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity制作动画短片【西部决斗】]]></title>
        <id>https://nicosq.github.io/post/unity-zhi-zuo-dong-hua-duan-pian-xi-bu-jue-dou/</id>
        <link href="https://nicosq.github.io/post/unity-zhi-zuo-dong-hua-duan-pian-xi-bu-jue-dou/">
        </link>
        <updated>2020-07-26T13:59:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="故事脚本">故事脚本</h2>
<p>在一个荒凉的西部小镇里，“赛亚人王子”贝吉塔刚刚来到这里，却发现这里渺无人烟，只得漫天的沙尘在这里肆虐。贝吉塔一直向前走，一个人也没看到，一个公告栏却映入他的眼帘。让人意想不到的就是，原来公告栏上挂着的，居然是贝吉塔的悬赏通缉令！贝吉塔一惊，随即提高了警惕。<br>
一阵脚步声想起，在这荒漠小镇中居然还有人？贝吉塔心想，猛地回头一看，正是著名的赏金猎人——空条承太郎向他走来。空条承太郎的来意，正是为了赏单上的那一笔巨款。一场对决无可避免。<br>
经历了拳拳到肉的对决后，贝吉塔在丝血一刻一套连招将承太郎打趴下，并放出了他的光波，将地上的承太郎炸成灰烬。<br>
正当贝吉塔沾沾自喜的时候，一声“白金之星 THE WORLD”这一声正正就是承太郎的时间暂停技能的声音，预示着承太郎并没有被炸飞，留下结局悬念。</p>
<hr>
<h2 id="制作过程">制作过程</h2>
<p><strong>3D max里面进行角色动作k帧（模型素材均来自网上）</strong></p>
<p>在3d max里面，我们对两个角色模型进行动作设计以及实现，让他能够实现自然的动作和姿态，最后形成一整段流畅的打斗部分以及其他场景。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4pcekk1yj30km05zmy0.jpg" alt="1_1.png"  />
<figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4pcv0qo7j30k906uju8.jpg" alt="1_2.png" loading="lazy"></figure>
<p><strong>Unity进行场景设计与渲染</strong></p>
<p>为了营造出西部的感觉，我们寻找了一个荒漠的乡村从场景，并且为了加强这种荒漠荒凉的气氛，我们在Unity里面利用粒子模块进行了风沙，云层，烟雾以及火光等效果的添加，并改变了灯光渲染效果。让整个场景看起来更加有西部的味道，烘托出故事的背景。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4pfb6v81j30lw0g4tin.jpg" alt="1_3.png" style="zoom:80%;" />
<p><strong>利用 Timeline 和 Cinemachine 插件进行人物动作编排和运动镜头添加</strong></p>
<p>我们构思了镜头和脚本，并制作出了所需要用到的动作。利用 3D max 里面导出来的动作FBX文件，导入到 Unity Timeline 里进行动作的编排与摄像机布置与运动，以达到我们想要的效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4pi2k39jj30le0c3n74.jpg" alt="1_4.png"  />
<figure data-type="image" tabindex="2"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4pjz14iyj30l305rq7e.jpg" alt="1_6.png" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4pitq1mej30li07qjss.jpg" alt="1_5.png" loading="lazy"></figure>
<ul>
<li><strong>利用 AE 合成特效，PR 剪辑导出视频</strong></li>
</ul>
<p>利用Unity渲染出来的视频已经具有丰富的场景效果（风沙、灯光、烟雾、火光等），在 AE 中我们添加特效丰富打击感与速度感，界面效果以及其他一切特效元素。</p>
<figure data-type="image" tabindex="4"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4plkg86jj30i809xmzz.jpg" alt="1_7.png" loading="lazy"></figure>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4pm6w8dmj30l90bkag5.jpg" alt="1_8.png"  />
<figure data-type="image" tabindex="5"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh4pmji6orj30j30agq59.jpg" alt="1_9.png" loading="lazy"></figure>
<hr>
<h2 id="视频展示">视频展示</h2>
<div style="position: relative; padding: 30% 45%;">
<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=86952767&bvid=BV1t7411H7zq&cid=148580318&page=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no"></iframe>
</div>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity大片草地渲染4（草的交互）]]></title>
        <id>https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-4cao-de-jiao-hu/</id>
        <link href="https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-4cao-de-jiao-hu/">
        </link>
        <updated>2020-07-24T03:08:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>上篇文章中我们讲完了草的着色器，已经成功生成了草。但是我们的场景还是略显单调，所以最后为我们的草加上交互效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh13on89svj30ok0dr7fa.jpg" alt="4_1.gif" style="zoom:80%;" />
<hr>
<h2 id="思路图">思路图</h2>
<figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh2feyj3wrj30nl05lgly.jpg" alt="4_10.png" loading="lazy"></figure>
<hr>
<h2 id="正文">正文</h2>
<p>首先先来看第一个效果——风的交互。</p>
<p>风的交互有很多种实现的方法，<strong>本质上就是对草的顶点进行偏移</strong>。比如可以使用简单的 sin 函数或者 cos 函数对顶点进行偏移，同时要注意的一点是<strong>草的根部是固定不动的</strong>，这一点可以利用草的 UV 的 Y 坐标来进行控制。这里就不贴代码了，实现的方法很简单，我们直接来看一下效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh1xrxs3wfg30l40ct7wh.gif" alt="4_1.gif" style="zoom:80%;" />
<p>可以看到我们的草发生了摆动，但是这个摆动太过于规律了，当草的数量一增多效果就很平庸，当然可以利用数学知识制作更加复杂的效果，但这个并不是本次要提到的重点，下面来介绍一下我这里使用的方法。</p>
<pre><code class="language-cs">Shader &quot;My Shaders/GrassShader&quot;
{
    Properties
    {
		......

		_WindTex(&quot;WindTex&quot;, 2D) = &quot;white&quot; {}          //风的采样贴图
		_WindVector(&quot;WindVector&quot;, Vector) = (1,1,1,0)          //控制风的方向
		_WindTimeScale(&quot;WindTimeScale&quot;, float) = 1          //控制风的速度
		_WindTexMapSize(&quot;WindTexMapSize&quot;, float) = 80          //控制风的采样贴图大小
		_WindXZStrength(&quot;WindXZStrength&quot;, float) = 10          //控制风在草的XZ轴上的偏移
		_WindYStrength(&quot;WindYStrength&quot;, float) = 10          //控制风在草的Y轴上的偏移          
	}

	SubShader
	{
		......

		Pass
		{
			......

			sampler2D _WindTex;
			float4 _WindTex_ST;
			half4 _WindVector;
			half _WindTimeScale;
			float _WindTexMapSize;
			half _WindXZStrength;
			half _WindYStrength;

			......
			
			//几何着色器
			[maxvertexcount(30)]
			void geom(point v2g points[1], inout TriangleStream&lt;g2f&gt; triStream) {
				
				......

				//进行生成全部草顶点的循环
				for (int i = 0; i &lt; vertexCount; i++)
				{
					......
                        
					//对顶点 Y 轴进行旋转
					pos = mul(lastTransformMatrix, mul(rotateMatrix, mul(firstTransformMatrix, pos)));

					//--风
					//将世界坐标下的风的方向转化为局部坐标
					float4 localWindDir = normalize(mul(unity_WorldToObject, _WindVector));
					//控制风速（实际上为采样 uv 的移动速度）
					float time = (_Time.y)*(_WindTimeScale);
					//对风贴图进行采样
					half4 rootWorldPos = mul(unity_ObjectToWorld, root);
					//windmutation 一直在 0~1 之间变化 
					float windmutation = 1 - tex2Dlod(_WindTex, float4(rootWorldPos.x / _WindTexMapSize + time, rootWorldPos.z / _WindTexMapSize, 0, 0)).g;
					//sin(time + windmutation * 10) * cos(time * 2 / 3 + 1 + windmutation * 10) -1~1
					//localWindDir.xz 控制风的方向
					//clamp(uv.y - 0.1, 0, 1) UV.y 范围在 0.1 以下的顶点不发生移动 
					//xz 轴上的偏移
					half2 xzOffset = sin(time + windmutation * 10) * cos(time * 2 / 3 + 1 + windmutation * 10) * localWindDir.xz * clamp(uv.y - 0.1, 0, 1);
					pos.xz += xzOffset * _WindXZStrength;
					//根据 XZ 轴上的偏移算出在 Y 轴上
					//直角三角形定理
					//Y轴的偏移
					half yOffset = pos.y - sqrt(pos.y * pos.y - (xzOffset.x * xzOffset.x + xzOffset.y * xzOffset.y));
					pos.y -= yOffset * _WindYStrength * clamp(uv.y - 0.35, 0, 1);

					//pos.xz += sin(_Time.y * _WindTimeScale) * uv.y;

					v[i] = GetVertex(pos, points[0].normal, uv);
				}

				//inout TriangleStream&lt;g2f&gt; triStream 输出三角形，即三个顶点数据
				//将每三个顶点转化为三角形输出到片元着色器
				for (int p = 0; p &lt; (vertexCount - 2); p++)
				{
					//triStream.Append(vertex); 该方法将输入的三个顶点自动构建成三角形
					triStream.Append(v[p]);
					triStream.Append(v[p + 2]);
					triStream.Append(v[p + 1]);
				}
			}

			......

			ENDCG
		}
    }
    
	Fallback &quot;Diffuse&quot;
}
</code></pre>
<p>在这里主要修改几何着色器里面的部分，可以看到在 <em>Properties</em> 里面我们创建了很多新的参数，大多数都标有注释。需要提到的就是<strong>我们定义了一个 <em>_WindTex</em> 来接受一张贴图，这张贴图可以帮我们模拟出一层一层风吹草地的效果</strong>，我们先看一下这张贴图。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh255vff0fj30or0or104.jpg" alt="4_2.png" style="zoom: 33%;" />
<p>这张贴图有什么作用呢？我们结合几何着色器新增加的风的代码来看。首先我们将我们定义的风的方向 <em>_WindVector</em> 转为局部坐标下 ，注意看到下面这一段：</p>
<pre><code class="language-cs">//控制风速（实际上为采样 uv 的移动速度）
float time = (_Time.y)*(_WindTimeScale);
//对风贴图进行采样
half4 rootWorldPos = mul(unity_ObjectToWorld, root);
//windmutation 一直在 0~1 之间变化 
float windmutation = 1 - tex2Dlod(_WindTex, float4(rootWorldPos.x / _WindTexMapSize + time, rootWorldPos.z / _WindTexMapSize, 0, 0)).g;
</code></pre>
<p>这里看似很长，其实很好理解。<strong>原理就是利用草的世界空间下的坐标组成 UV 来对这张贴图进行采样，并且注意要加上 UV 的偏移。而 <em>_WindTexMapSize</em> 参数是为了控制贴图采样的大小</strong>。可以结合下面这张图理解。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh25hu0oo8j30qz0g0q4p.jpg" alt="4_3.png" style="zoom:50%;" />
<p>我们计算出了采样结果 <em>windmutaition</em> 。然后下面这一段是对草的每个顶点进行偏移。</p>
<pre><code class="language-cs">//localWindDir.xz 控制风的方向
//clamp(v[i].uv.y - 0.1, 0, 1) UV.y 范围在 0.1 以下的顶点不发生移动 
//xz 轴上的偏移
half2 xzOffset = sin(time + windmutation * 10) * cos(time * 2/3 + 1 + windmutation * 10) * localWindDir.xz * clamp(uv.y - 0.1, 0, 1);
pos.xz += xzOffset * _WindXZStrength;
//根据 XZ 轴上的偏移算出在 Y 轴上
//直角三角形定理
//Y轴的偏移
half yOffset = pos.y - sqrt(pos.y * pos.y - (xzOffset.x * xzOffset.x + xzOffset.y * xzOffset.y));
pos.y -= yOffset * _WindYStrength * clamp(uv.y - 0.35, 0, 1);
</code></pre>
<p><strong>我们利用 sin 函数的变化来控制顶点 XZ 方向上的偏移，利用 <em>localWindDir</em> 参数来控制风的方向。在控制 Y 轴的偏移上，我们利用直角三角形的勾股定理，通过 XZ 轴上的偏移大致计算出每根顶点在 Y 轴上的偏移。最后要注意通过草的在竖直上的 UV 值（clamp函数）来控制偏移程度（草的根部不动）</strong>。计算很简单，可以结合这张图来理解。<strong>（△y 是要计算的部分）</strong></p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh2636zkqxj30p80hldgx.jpg" alt="4_4.png" style="zoom:50%;" />
<p>来看看现在的效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh266qkgaag30l40ct4qs.gif" alt="4_5.gif" style="zoom: 80%;" />
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh26a56ftcg30pq0e0npj.gif" alt="4_6.gif" style="zoom:80%;" />
<p>可以看到效果很不错，很好的模拟出一层层风浪的效果。并且还可以自己制作风浪贴图，调整风速、控制风的形状以及方向等参数。</p>
<p>接下来是第二个交互效果，玩家的交互。</p>
<p>说是玩家的交互，本质上也是草的顶点的偏移。<strong>不同的就是玩家是世界空间下不停移动的人物，这就需要我们将玩家的位置传给着色器</strong>。</p>
<p>我们创建一个 <em>MoveControl</em> 的脚本，挂载在一个默认的 <em>Capsule</em> 下。</p>
<pre><code class="language-cs">public class MoveControl : MonoBehaviour
{
    public Material grassMaterial;
    public float speed = 10f;

    void Update()
    {
        grassMaterial.SetVector(&quot;_PlayerPos&quot;, this.gameObject.transform.position + Vector3.up * 0.5f);
        MoveMent();
    }

    void MoveMent()
    {
        if (Input.GetKey(KeyCode.W))
        {
            transform.Translate(transform.forward * Time.deltaTime * speed);
        }
        else if (Input.GetKey(KeyCode.S))
        {
            transform.Translate(-transform.forward * Time.deltaTime * speed);
        }
        else if (Input.GetKey(KeyCode.A))
        {
            transform.Translate(-transform.right * Time.deltaTime * speed);
        }
        else if (Input.GetKey(KeyCode.D))
        {
            transform.Translate(transform.right * Time.deltaTime * speed);
        }
    }
}
</code></pre>
<p>代码很简单，只有一些简单的控制移动的代码。其中在 <strong><em>Update</em> 函数里面我们需要向我们的草材质传递我们 <em>Capsule</em> 的位置信息</strong>。</p>
<p>来看一下着色器增加的部分。</p>
<pre><code class="language-cs">Shader &quot;My Shaders/GrassShader&quot;
{
    Properties
    {
		......

		_InteracRadius(&quot;InteracRadius&quot;, Range(0.5, 20)) = 1          //控制玩家与草交互的半径
		_InteracStrength(&quot;InteracStrength&quot;, Range(0.5, 20)) = 1          //控制玩家与草交互的强度
	}

	SubShader
	{
		......

		Pass
		{
			......

			//玩家的位置
			float4 _PlayerPos;
			half _InteracRadius;
			half _InteracStrength;

			......
			
			//几何着色器
			[maxvertexcount(30)]
			void geom(point v2g points[1], inout TriangleStream&lt;g2f&gt; triStream) {
				
				......
                    
				//进行生成全部草顶点的循环
				for (int i = 0; i &lt; vertexCount; i++)
				{
					......
					//对顶点 Y 轴进行旋转
					pos = mul(lastTransformMatrix, mul(rotateMatrix, mul(firstTransformMatrix, pos)));

					//--交互
					//--与玩家的交互
					float3 worldPos = mul(unity_ObjectToWorld, pos).xyz;
					//每根草的顶点与玩家的距离
					float3 dis = distance(_PlayerPos, worldPos);
					//将这段距离由进到远的范围缩小为 0~1
					float3 circle = 1 - saturate(dis / _InteracRadius);
					//每根草的顶点倒下的方向
					float3 dir = normalize(worldPos - _PlayerPos);
					float3 strength = dir * circle;
					//XZ 轴上的移动
					pos.xz += strength * _InteracStrength * uv.y;
					//Y 轴上的移动
					float2 InterOffsetXZ = strength * _InteracStrength * uv.y;
					pos.y -= pos.y - sqrt(pos.y * pos.y - (InterOffsetXZ.x * InterOffsetXZ.x + InterOffsetXZ.y * InterOffsetXZ.y));
					
                    //风的交互
					......

					v[i] = GetVertex(pos, points[0].normal, uv);
				}

				......
			}

			......
		}
    }
    
	Fallback &quot;Diffuse&quot;
}
</code></pre>
<p>在上一段风的交互代码前我们增加与玩家交互的代码，可以看到我们引入了由脚本传过来的玩家的世界坐标变量 <em>_PlayerPos</em>。<strong>首先将我们每根草的顶点转到世界空间下，并利用 <em>distance</em> 函数计算出每个顶点与玩家的距离。注意我们在开头还添加了两个变量 <em>_InteracRadius</em> 和 <em>_InteracStrength</em>，这两个变量分别控制玩家与草交互的范围与强度。接下来我们利用向量的知识得到每根草的顶点倒下来的方向，后面的顶点偏移就跟风的交互差不多了</strong>。</p>
<p>让我们来看看效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh2dwhgzp5g30pq0e0x6v.gif" alt="4_7.gif" style="zoom: 50%;" />
<p>可以看到 <em>Capsule</em> 经过的地方草的位置发生了偏移。但是这种方法想要达到好的效果需要调整的东西有很多，比如传入的 <em>_PlayerPos</em> 的位置就需要根据实际需求来进行调整。</p>
<p>最后来讲一下静止物体的交互效果。</p>
<p>说是静止物体，其实同样也适用于运动的物体。<strong>在游戏中通常都会看到这样的场景，比如一架飞船降落在大草原上，草原上通常会形成像水面涟漪一样一层层散开的效果</strong>。我查阅了网上的资料，发现了一个很好玩的<strong>制作水面涟漪的方法：粒子 + 纹理相机</strong>。我将这个方法移植到草着色器的风压效果中，同开头讲到的风的交互的方法差不多，<strong>通过建立 UV 坐标采样相机渲染的粒子纹理来对草的顶点进行偏移</strong>。</p>
<p>这一步就不贴上代码了。<strong>具体设置的方法可以参考那一篇《Making Interactive Water using RenderTexture》的文章，我会贴在末尾的参考资料中</strong>。直接来看看效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh2f8g3sxmg30ob0cjnpi.gif" alt="4_8.gif" style="zoom: 67%;" />
<p>可以看到周围的风压效果。想要更改参数也很简单，只要控制粒子生成的效果，就可以做到很多不同形式的风压效果。</p>
<hr>
<h2 id="后记">后记</h2>
<p>至此，我们的《Unity大片草地渲染系列》已经基本完成了目标。</p>
<p>整个项目中学到了很多新的东西和知识。当然，最后做出来的效果还有很多可以优化的地方。比如草的光照优化，Billboard 和阴影的添加等。等到日后有时间再继续补充吧。</p>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>Unity 大面积草风吹动效果+受人物影响</p>
<p><a href="https://blog.csdn.net/qq_33967521/article/details/85205938">https://blog.csdn.net/qq_33967521/article/details/85205938</a></p>
</li>
<li>
<p>Quick Game Art Tips - Interactive Grass Shader</p>
<p><a href="https://www.patreon.com/posts/quick-game-art-19844414">https://www.patreon.com/posts/quick-game-art-19844414</a></p>
</li>
<li>
<p>Making Interactive Water using RenderTexture</p>
<p><a href="https://www.patreon.com/posts/24192529">https://www.patreon.com/posts/24192529</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity大片草地渲染3（草着色器）]]></title>
        <id>https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-3cao-zhao-se-qi/</id>
        <link href="https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-3cao-zhao-se-qi/">
        </link>
        <updated>2020-07-23T13:37:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在上篇文章中，我们生成了草的顶点集。在正式开始前，首先来补充上一篇文章留下的优化方案之一：<strong>草的法线生成</strong>——<strong>利用地形网格的法线来生成草的法线</strong>。思路其实很简单，就是创建一个 <em>terrainNormals</em> 的数组来存储地形网格每一个顶点的法线，并把它传入草的着色器来进行后续的计算。</p>
<p>来看看代码，<strong>这里只添加补充和修改的部分</strong>。</p>
<pre><code class="language-cs">	#region Terrain Data
	......
        
    Vector3[] terrainNormals;          //存储地形的顶点法线的一维数组
    Vector3[,] terrainNormals2D;          //存储地形的顶点法线的二维数组
    #endregion

    #region Grass Data
    ......
        
    Vector3[] grassNormals;          //存储草的顶点法线
    List&lt;Vector3&gt; grassNormalList = new List&lt;Vector3&gt;();          //存储草的顶点法线列表
    #endregion

    void Start()
    {
        ......

        terrainNormals = new Vector3[terrainSize * terrainSize];
        terrainNormals2D = new Vector3[terrainSize, terrainSize];
		......
    }

   ......
       
    //生成地形
    void GenerateTerrain()
    {
       	......
            
        //为了得到正确的光照需要重新计算得到正确的法线信息
        groundMesh.RecalculateNormals();
        terrainNormals = groundMesh.normals;

        //将存储地形法线数组从一维数组转为二维，便于索引
        for (int i = 0; i &lt; terrainSize; i++)
        {
            for (int j = 0; j &lt; terrainSize; j++)
            {
                terrainNormals2D[i, j] = terrainNormals[i * terrainSize + j];
            }
        }

        Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
		......
    }

    //生成草的网格数据
    void GenerateGrassArea(int rowCount, int perPatchSize)
    {
 		......

        //当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
        //创立多个网格处理
        while (grassVerts.Count &gt; 65000)
        {
            grassMesh = new Mesh();
            grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();
   
            //存储每个草顶点的法线（当顶点超过 65000个）
            grassNormals = new Vector3[65000];
            grassNormalList.GetRange(0, 65000);
            for (int i = 0; i &lt; 65000; i++)
            {
                grassNormals[i] = grassNormalList[i];
            }

           	......
            grassMeshRenderer.sharedMaterial = grassMat;
            grassMesh.normals = grassNormals;
            grassMeshFilter.mesh = grassMesh;
            //移除前 65000 个顶点
            grassVerts.RemoveRange(0, 65000);
            //移除前 65000 个法线信息
            grassNormalList.RemoveRange(0, 65000);
        }

        //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时
        ......
         
        //存储每个草顶点的法线（当顶点没有超过 65000个）
        grassNormals = new Vector3[grassMesh.vertexCount];
        grassNormalList.GetRange(0, grassMesh.vertexCount);
        for (int i = 0; i &lt; grassMesh.vertexCount; i++)
        {
            grassNormals[i] = grassNormalList[i];
        }
        grassMesh.normals = grassNormals;
        
		......
    }

    //生成草
    void GenerateGrass(Vector3 vertPos, Vector3 patchSize, int grassCountPerPatch)
    {
        //每一堆 草根集 里的草进行循环
        for (int i = 0; i &lt; grassCountPerPatch; i++)
        {
            ......
                
            //添加每一个草的顶点位置到 grassVert 列表里
            grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, vertPos.z + randomZ));
            //添加每一个草的顶点法线到 grassNormalList 列表里
            grassNormalList.Add(terrainNormals2D[indexX, indexZ]);
        }
    }
</code></pre>
<p>大致上很好理解，首先在创建地形网格的时候，利用大小为 250 * 250 的 <em>terrainNormals</em> 数组来存储所有对应的网格顶点。在这里，<strong>我将一维数组 <em>terrainNormals</em> 转为了二维数组 <em>terrainNormals2D</em>，原因是因为后面在索引每个法线值时需要用到点的 X 和 Z 坐标。在 <em>GenerateGrass</em> 函数中，在最后记得索引每个网格顶点的法线值，并存入列表 <em>grassNormalList</em> 列表中。</strong></p>
<p>在赋予每个草顶点法线时，同上一篇文章的添加草顶点时一样，<strong>记得每次索引 <em>grassNormalList</em> 中前 65000 个法线值，并在最后移除这一部分，再次进入下一个循环。</strong></p>
<p>来看看效果图，<strong>这里我换了一个天空盒，设置片元着色器用法线输出颜色。</strong></p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh12bs8dalj30po0dtqcg.jpg" alt="3_11.png" style="zoom:80%;" />
<p>这里可以看到大部分草的颜色都呈现绿色，细看的话可以看到不同草之间的绿色存在深浅差异。<strong>呈现绿色的原因也很简单，因为地形网格的法线值大部分都是 float3(0,1,0)，沿 Y 轴指向上，而部分因为地形的影响有所偏移，所以呈现的绿色有深浅差异</strong>。我们用在片元着色器中实现简单的光照（草的贴图颜色和漫反射相乘）来看看效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh12emumezj30on0duwon.jpg" alt="3_12.png" style="zoom:80%;" />
<p>可以看到大致的光照效果出来了，而且经过测试，不管怎样旋转光的方向，草与地形的光照效果基本契合。</p>
<p>前言部分大概就到这，主要是补充上一篇文章的思路。这一片文章我们将会讲到如何在 <em>shader</em> 里面利用<strong>几何着色器</strong>生成草，并实现更加复杂的草的光照。</p>
<hr>
<h2 id="思路图">思路图</h2>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh18qvizj9j30qb07qdg4.jpg" alt="3_18.png" style="zoom:80%;" />
<hr>
<h2 id="正文">正文</h2>
<p>我们都知道 <em>shader</em> 中经常提到的<strong>顶点着色器</strong>和<strong>片元着色器</strong>，却很少听过<strong>几何着色器</strong>。在真正讲解前，我们要先了解什么是<strong>几何着色器</strong>。</p>
<p>先来看一张简化的渲染管道流程图。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggzloiedhjj308s0lvacx.jpg" alt="3_4.png" style="zoom:80%;" />
<p>在上面渲染管线的流程图中，我们可以看到我们熟悉的 <strong>Vertex shader（顶点着色器）</strong> 和 <strong>Fragment shader（片元着色器）</strong> ，也可以清楚的看到连在两个之间的 <strong>Geometry shader（几何着色器）</strong>。</p>
<blockquote>
<p><strong>在渲染过程中通常会听到一个概念叫做图元，图元的结构可以是点、线或者三角形。在渲染管线的开始，GPU处理由应用阶段加载到显存中的每一个顶点数据，并且GPU是知道每一个顶点是属于哪个三角形的。所有顶点经过顶点着色器处理后输出的结果会经过一个图元装配(Primitive Assembly)的阶段，这个阶段就是把这些处理后的顶点组装成一个个图元（通常是三角形）。之后的步骤中无论是光栅化和顶点信息插值过程，以及视椎体的裁剪，都是以图元为单位进行的。</strong></p>
</blockquote>
<p><strong>而几何着色器是顶点着色器和片元着色器之间的可选的过渡阶段。几何着色器的作用是得到从顶点着色器获取的图元信息，并对这些顶点数据进行添加，删除，或修改，然后输出新的图元信息（通常是三角形），并将最终信息发送到片元着色器进行着色，照明等。</strong></p>
<p>简单来说就是几何着色器可以对输入的顶点数据进行增删改等进行一系列操作，并组成新的图元。现在我们结合代码来理解。</p>
<pre><code class="language-cs">Shader &quot;My Shaders/GrassShader&quot;
{
    Properties
    {
		[HDR]_GrassColor(&quot;GrassColor&quot;, Color) = (1,1,1,1)          //控制草的颜色
		_SpecualarColor(&quot;SpecularColor&quot;, Color) = (1,1,1,1)          //控制草的高光颜色
		_Specular(&quot;_Specular&quot;, Range(0, 1)) = 1          //控制草的高光程度
		_Gloss(&quot;Gloss&quot;, Range(0,20)) = 1          //控制草的高光
		[HDR]_FresnelColor(&quot;FresnelColor&quot;, Color) = (1,1,1,1)          //控制草的边缘高光颜色
		_FresnelPower(&quot;FresnelPower&quot;, Range(0, 5)) = 1          //控制草的边缘高光程度          
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}          //草的颜色贴图
		_AlphaTex(&quot;AlphaTexture&quot;, 2D) = &quot;white&quot; {}          //草的透明贴图
		_GrassHeight(&quot;GrassHeight&quot;, Range(0.5, 5)) = 2.5          //控制草的高度
		_GrassWidth(&quot;GrassWidth&quot;, Range(0.001, 0.5)) = 0.05          //控制草的宽度
	}

	SubShader
	{
		//存在顶点动画，所以要关闭批处理，DisableBatching 设置为 True
		Tags {
			&quot;RenderType&quot; = &quot;TransparentCutout&quot;
			&quot;IgnoreProjector&quot; = &quot;True&quot;
			&quot;Queue&quot; = &quot;AlphaTest&quot;
			&quot;DisableBatching&quot; = &quot;True&quot;
		}

		//设置为双面渲染，关闭背面剔除
		Cull Off
		LOD 100

		Pass
		{
			//设置为前向渲染模式
			Tags { &quot;LightMode&quot; = &quot;ForwardBase&quot; }
			Cull Off
			AlphaToMask On

			CGPROGRAM
			//引入头文件
			#include &quot;UnityCG.cginc&quot;
			#include &quot;Lighting.cginc&quot;
			#include &quot;AutoLight.cginc&quot;

			//要应用几何着色器必须要将编译目标设置为 4.0 
			#pragma target 4.0
			#pragma multi_compile_fwdbase
			#pragma vertex vert
			#pragma fragment frag
			//定义几何着色器
			#pragma geometry geom

			fixed4 _GrassColor;
			fixed4 _SpecualarColor;
			fixed _Specular;
			float _Gloss;
			fixed4 _FresnelColor;
			half _FresnelPower;
			sampler2D _MainTex;
			float4 _MainTex_ST;
			sampler2D _AlphaTex;
			fixed _GrassHeight;
			fixed _GrassWidth;

			struct a2v {
				float4 pos : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};

			//顶点着色器传给几何着色器的数据结构
			struct v2g {
				float4 pos : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};

			//几何着色器传给片元着色器的数据结构
			struct g2f {
				float4 pos : SV_POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
				float3 worldPos : TEXCOORD1;
			};

			//顶点着色器
			//直接将从网格得到的数据传给传入几何着色器的结构体 v2g
			v2g vert(a2v v) {
				v2g o;
				o.pos = v.pos;
				o.normal = v.normal;
				o.uv = v.uv;
				return o;
			}

			//创建 CreatG2fOut() 函数
			//初始化从几何着色器传入片元着色器的结构体 g2f
			g2f CreatG2fOut() {
				g2f output;
				output.pos = float4(0, 0, 0, 0);
				output.normal = float3(0, 0, 0);
				output.uv = float2(0, 0);
				output.worldPos = float3(0, 0, 0);
				return output;
			}
			
			g2f GetVertex(float4 pos, float3 normal, float2 uv) {
				g2f output;

				output.pos = UnityObjectToClipPos(pos);	
				output.normal = UnityObjectToWorldNormal(normal);
				output.uv = uv;
				output.worldPos = UnityObjectToWorldDir(pos);

				return output;
			}
			
			//几何着色器
			[maxvertexcount(30)]
			void geom(point v2g points[1], inout TriangleStream&lt;g2f&gt; triStream) {
				
				//顶点着色器输入的顶点位置
				float4 root = points[0].pos;

				//生成一个伪随机数
				float random = sin(UNITY_HALF_PI * frac(root.x) + UNITY_HALF_PI * frac(root.z));
				//给每根草的长宽加上这个随机值，我们希望草的宽度不要太宽或者太窄
				_GrassWidth = _GrassWidth + (random / 50);
				_GrassHeight = _GrassHeight + (random / 5);

				//设置草的网格顶点一共有12个
				const int vertexCount = 12;

				//创建12个 g2f 输出数组
				g2f v[vertexCount] = {
					CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut(),
					CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut(),
					CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut()
				};

				//初始化每个顶点的位置 pos 和 uv
				float4 pos = float4(0, 0, 0, 0);
				float2 uv = float2(0, 0);

				//顶点的 UV 在竖直方向上的当前值和偏移值
				float currentV = 0;
				float offsetV = 1.0 / (vertexCount / 2 - 1);

				//顶点的 y 坐标在竖直方向上的当前值的偏移值
				float currentVertexHeight = 0;
				float currentHeightOffset = 0;
				float verticalEff = 0;

				//进行生成全部草顶点的循环
				for (int i = 0; i &lt; vertexCount; i++)
				{
					//fmod(a,b) 返回 a 除 b 的余数
					//如果返回值为偶数，顶点 UV 坐标均为(0,V)
					if (fmod(i, 2) == 0) {
						pos = float4(root.x - _GrassWidth, root.y + currentVertexHeight, root.z, 1);
						uv = fixed2(0, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;
					}
					else {
						pos = float4(root.x + _GrassWidth, root.y + currentVertexHeight, root.z, 1);
						uv = fixed2(1, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;

						currentV += offsetV;
						currentVertexHeight += currentV * _GrassHeight;
					}

					v[i] = GetVertex(pos, points[0].normal, uv);
				}

				//inout TriangleStream&lt;g2f&gt; triStream 输出三角形，即三个顶点数据
				//将每三个顶点转化为三角形输出到片元着色器
				for (int p = 0; p &lt; (vertexCount - 2); p++)
				{
					//triStream.Append(vertex); 该方法将输入的三个顶点自动构建成三角形
					triStream.Append(v[p]);
					triStream.Append(v[p + 2]);
					triStream.Append(v[p + 1]);
				}
			}

			//片元着色器
			//简单的 Blin-Phong 光照模型
			float4 frag(g2f i) : SV_Target{

				//对_MainTex纹理和_AlphaTex纹理进行采样
				fixed4 texColor = tex2D(_MainTex, i.uv);
				fixed alpha = tex2D(_AlphaTex, i.uv).a;

				//将法线归一化
				float3 worldNormal = normalize(i.normal);
				float3 worldSpecNormal = worldNormal;
				worldNormal = worldNormal * 0.5 + 0.5;

				//得到环境光
				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
				//得到世界空间下光照方向
				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));

				//Diffuse 漫反射颜色
				fixed NdotL = saturate(dot(worldNormal, worldLightDir));
				fixed3 diffuse = _LightColor0.rgb * NdotL;

				//Specular 高光颜色
				//得到世界空间下的视线方向
				fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
				//得到半角向量
				fixed3 halfDir = normalize(worldLightDir + worldViewDir);
				fixed3 NdotH = saturate(dot(worldSpecNormal, halfDir));
				float spec = pow(NdotH, _Specular * 128.0) * _Gloss;
				fixed3 specular = _SpecualarColor * _LightColor0.rgb * spec;

				//Fresnel
				fixed fresnel = saturate(1 - dot(worldSpecNormal, worldViewDir));
				//fresnel = clamp(fresnel - 0.2, 0, 1);
				fresnel = pow(fresnel, _FresnelPower) * clamp(i.uv.y - 0.5, 0, i.uv.y);
				fixed3 fresnelColor = fresnel * _FresnelColor * 2;

				//得到并输出最终颜色
				fixed3 finalColor = ambient + diffuse + specular + FresnelColor;
				return fixed4(texColor * _GrassColor.rgb * finalColor, alpha);
				//return fixed4(worldNormal, alpha);
			}
			ENDCG
		}
    }

	Fallback &quot;Diffuse&quot;
}
</code></pre>
<p>大部分代码可以结合参数解释。首先简单讲一下前面部分的代码。</p>
<p>首先我们需要像定义顶点和片元着色器一样定义<strong>几何着色器</strong>。可以看到我们定义了两个数据结构体为 <em>v2g</em> 和 <em>g2f</em> ，分别对应的是<strong>顶点着色器传入几何着色器</strong>和<strong>几何着色器传入片元着色器</strong>的数据结构体。另外，在顶点着色器中我们不需要对传入的数据进行任何操作，只要把所有数据传入几何着色器即可（<strong>因为几何着色器会在输出数据时执行顶点着色器的工作</strong>）。</p>
<pre><code class="language-csharp">			//要应用几何着色器必须要将编译目标设置为 4.0 
			#pragma target 4.0
			
            ......
                
			//定义几何着色器
			#pragma geometry geom

			......
               
			//顶点着色器传给几何着色器的数据结构
			struct v2g {
				float4 pos : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};

			//几何着色器传给片元着色器的数据结构
			struct g2f {
				float4 pos : SV_POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
				float3 worldPos : TEXCOORD1;
			};

			//顶点着色器
			//直接将从网格得到的数据传给传入几何着色器的结构体 v2g
			v2g vert(a2v v) {
				v2g o;
				o.pos = v.pos;
				o.normal = v.normal;
				o.uv = v.uv;
				return o;
			}

			//创建 CreatG2fOut() 函数
			//初始化从几何着色器传入片元着色器的结构体 g2f
			g2f CreatG2fOut() {
				g2f output;
				output.pos = float4(0, 0, 0, 0);
				output.normal = float3(0, 0, 0);
				output.uv = float2(0, 0);
				output.worldPos = float3(0, 0, 0);
				return output;
			}

			......
</code></pre>
<p>接下来就到了重点部分 —— 几何着色器。</p>
<pre><code class="language-cs">			......
                
            g2f GetVertex(float4 pos, float3 normal, float2 uv) {
				g2f output;

				output.pos = UnityObjectToClipPos(pos);			
				output.normal = UnityObjectToWorldNormal(normal);
				output.uv = uv;
				output.worldPos = UnityObjectToWorldDir(pos);

				return output;
			}

			//几何着色器
			[maxvertexcount(30)]
			void geom(point v2g points[1], inout TriangleStream&lt;g2f&gt; triStream) {
				
				//顶点着色器输入的顶点位置
				float4 root = points[0].pos;

				//生成一个伪随机数
				float random = sin(UNITY_HALF_PI * frac(root.x) + UNITY_HALF_PI * frac(root.z));
				//给每根草的长宽加上这个随机值，我们希望草的宽度不要太宽或者太窄
				_GrassWidth = _GrassWidth + (random / 50);
				_GrassHeight = _GrassHeight + (random / 5);

				//设置草的网格顶点一共有12个
				const int vertexCount = 12;

				//创建12个 g2f 输出数组
				g2f v[vertexCount] = {
					CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut(),
					CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut(),
					CreatG2fOut(), CreatG2fOut(), CreatG2fOut(), CreatG2fOut()
				};

				//初始化每个顶点的位置 pos 和 uv
				float4 pos = float4(0, 0, 0, 0);
				float2 uv = float2(0, 0);

				//顶点的 UV 在竖直方向上的当前值和偏移值
				float currentV = 0;
				float offsetV = 1.0 / (vertexCount / 2 - 1);

				//顶点的 y 坐标在竖直方向上的当前值的偏移值
				float currentVertexHeight = 0;
				float currentHeightOffset = 0;
				float verticalEff = 0;

				//进行生成全部草顶点的循环
				for (int i = 0; i &lt; vertexCount; i++)
				{
					//fmod(a,b) 返回 a 除 b 的余数
					//如果返回值为偶数，顶点 UV 坐标均为(0,V)
					if (fmod(i, 2) == 0) {
						pos = float4(root.x - _GrassWidth, root.y + currentVertexHeight, root.z, 1);
						uv = fixed2(0, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;
					}
					else {
						pos = float4(root.x + _GrassWidth, root.y + currentVertexHeight, root.z, 1);
						uv = fixed2(1, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;

						currentV += offsetV;
						currentVertexHeight += currentV * _GrassHeight;
					}

					v[i] = GetVertex(pos, points[0].normal, uv);
				}

				//inout TriangleStream&lt;g2f&gt; triStream 输出三角形，即三个顶点数据
				//将每三个顶点转化为三角形输出到片元着色器
				for (int p = 0; p &lt; (vertexCount - 2); p++)
				{
					//triStream.Append(vertex); 该方法将输入的三个顶点自动构建成三角形
					triStream.Append(v[p]);
					triStream.Append(v[p + 2]);
					triStream.Append(v[p + 1]);
				}
			}

			......
</code></pre>
<p>从上面可以知道，我们在几何着色器中可以<strong>对输入的顶点数据进行添加，删除，或修改，然后输出新的图元信息。在这里我们利用几何着色器增加顶点来生成草的网格。</strong></p>
<p>首先看到开头的<code>[maxvertexcount(30)]</code>。</p>
<blockquote>
<p><strong>这个语句是用来限制几何着色器输出的最大顶点数目。每当输入一个图元，几何着色器可以输出 0~N 个图元。不论是什么结构的图元都是由顶点构成的，而这个语句就是用来限制输出最大的顶点数量（只要小于等于这个数量就可以，多余的顶点会被剔除）。</strong></p>
</blockquote>
<p>接下来是下面一行：</p>
<pre><code class="language-cs">void geom(point v2g points[1], inout TriangleStream&lt;g2f&gt; triStream)
{
    ......
}
</code></pre>
<p>来看我们的函数声明，我们<strong>几何着色器接受的是图元，而这些图元数据就是以顶点结构数组的形式传进来的</strong>。什么意思呢？这里看到我们的声明的前半部分 <code>point v2g points[1]</code>，<strong>这里说明我们输入的图元结构是顶点，而顶点数组的数目就是 1。<strong>此外还可以输入的图元结构有</strong>线和三角形，他们的顶点数组数目分别对应 2 和 3</strong>。</p>
<pre><code class="language-cs">//线
line v2g points[2]    
//三角形
triangle v2g points[3]
</code></pre>
<blockquote>
<p><strong>为什么在这里传入的图元结构为<code>point</code>（顶点）呢？</strong></p>
<ul>
<li><strong>在上一篇文章中我们提到生成的草的网格拓补结构为点，这也是我们在这里使用<code>point</code>作为结构数组的原因。有一点需要注意的是，我们填写的图元结构不一定要和我们的网格拓补结构相同。比如传入的如果是Unity默认的网格结构（三角形），但是在这里我们仍然定义用<code>point</code>图元结构，结果就是你传入了三角形的三个顶点，但是只能接收一个。</strong></li>
</ul>
</blockquote>
<p>而函数声明的后半部分 <code>inout TriangleStream&lt;g2f&gt; triStream</code> <strong>决定的是我们输出的图元结构为三角形，并且每个顶点都使用 g2f 来携带数据，对应的输出数据流还有 LineStream（线）和 PointStream（点）。</strong></p>
<p>讲完函数声明，接下来来看我们来看函数内部。</p>
<p>首先我们生成一个 float4 类型的 root 变量来存储我们的顶点位置。在本次项目中我们设置草的顶点一共有12个，并通过循环确定和生成每一个顶点数据。<strong>而 GetVertex 函数负责对我们生成的每一个顶点进行赋值，记得要在输出之前进行顶点着色器没有完成的工作，将我们的顶点转到裁剪空间下，同时对其他数据进行相应的操作。</strong></p>
<p>关于如何循环和生成每一个顶点，可以结合下面这幅图来理解。</p>
<blockquote>
<p><strong>图中蓝色为每个顶点的 UV 坐标（在计算 UV 的时候注意范围在 0 到 1）</strong></p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggzwc64zwvj30kn0l0aco.jpg" alt="3_5.png" style="zoom:80%;" />
</blockquote>
<p>最后就是利用 <code>triangle.Append()</code>函数来把每个顶点添加到输出结构中。<strong>注意我们之前定义的是三角形的输出流，即需要三个顶点数据，而 <code>triangle.Append</code> 方法可以将生成的每三个顶点自动组成三角形输出。</strong></p>
<pre><code class="language-cs">				//inout TriangleStream&lt;g2f&gt; triStream 输出三角形，即三个顶点数据
				//将每三个顶点转化为三角形输出到片元着色器
				for (int p = 0; p &lt; (vertexCount - 2); p++)
				{
					//triStream.Append(vertex); 该方法将输入的三个顶点自动构建成三角形
					triStream.Append(v[p]);
					triStream.Append(v[p + 2]);
					triStream.Append(v[p + 1]);
				}
</code></pre>
<p>先来看看现在的效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggzwpdok6ij30p10e1k2z.jpg" alt="3_6.png" style="zoom:80%;" />
<p>这里我使用的 _MainTex 贴图和 _AlphaTex 贴图如图所示：</p>
<blockquote>
<ul>
<li>左边为 _MainTex 贴图，右边为 _AlphaTex 贴图（<strong>带Alpha通道</strong>）</li>
</ul>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggzxjzyqxvj30jt09jjr8.jpg" alt="3_7.png" style="zoom:50%;" />
</blockquote>
<p>现在还存在一些问题，我们用一个Unity自带的网格来进行测试，换上我们的草材质球。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggzxmxnypwj30gg0dp0wo.jpg" alt="3_8.png" style="zoom:80%;" />
<p>这里我为了看得更明显加大的了草的宽度，可以看到所有的草都朝向统一的方向，这样的话从侧面看会产生一种草消失的错觉。同时每根草都笔直地朝向上方，这样会显得很生硬。<strong>解决问题的方法也很简单，只要为每根草的顶点做 XZ 轴上的偏移，同时在 Y 轴上进行旋转即可</strong>。我们继续来修改一下我们的代码。</p>
<pre><code class="language-cs">Shader &quot;My Shaders/GrassShader&quot;
{
    Properties
    {
		......
            
		_BladeForward(&quot;BladeForward&quot;, Range(0, 2)) = 1          //控制草的弯曲程度
	}

	SubShader
	{
		......

		Pass
		{
			......
                
			fixed _BladeForward;

			......

			//几何着色器
			[maxvertexcount(30)]
			void geom(point v2g points[1], inout TriangleStream&lt;g2f&gt; triStream) {
				
				......

				//让草绕着自身的 y 轴进行旋转
				//生成一个随机角度
				fixed randomAngle = frac(sin(root.x)*10000.0) * UNITY_HALF_PI;

				//根据矩阵旋转的定理，分别创建旋转矩阵
				//平移矩阵，先将所有点平移到原点
				float4x4 firstTransformMatrix = float4x4(
					1.0, 0.0, 0.0, -root.x,
					0.0, 1.0, 0.0, -root.y,
					0.0, 0.0, 1.0, -root.z,
					0.0, 0.0, 0.0, 1.0
					);

				//旋转矩阵
				float4x4 rotateMatrix = float4x4(
					cos(randomAngle), 0, sin(randomAngle), 0,
					0, 1, 0, 0,
					-sin(randomAngle), 0, cos(randomAngle), 0,
					0, 0, 0, 1
					);

				//再平移回去
				float4x4 lastTransformMatrix = float4x4(
					1.0, 0.0, 0.0, root.x,
					0.0, 1.0, 0.0, root.y,
					0.0, 0.0, 1.0, root.z,
					0.0, 0.0, 0.0, 1.0
					);				
				
                ......

				//进行生成全部草顶点的循环
				for (int i = 0; i &lt; vertexCount; i++)
				{
					//fmod(a,b) 返回 a 除 b 的余数
					//如果返回值为偶数，顶点 UV 坐标均为(0,V)
					if (fmod(i, 2) == 0) {
						pos = float4(root.x - _GrassWidth, root.y + currentVertexHeight, root.z, 1);
						uv = fixed2(0, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;
					}
					else {
						pos = float4(root.x + _GrassWidth, root.y + currentVertexHeight, root.z, 1);
						uv = fixed2(1, currentV) * _MainTex_ST.xy + _MainTex_ST.zw;

						currentV += offsetV;
						currentVertexHeight += currentV * _GrassHeight;
					}
					
					//对顶点 XZ 轴进行偏移
					float2 randomDir = float2(sin((random * 15)), sin((random * 10)));
					float2 forward = (sin((root.x * 10 + root.z / 5) * random)* verticalEff + randomDir * sin((random * 15)))* verticalEff;
					pos.xz += forward * _BladeForward;
					if (fmod(i, 2) == 1) {
						verticalEff += offsetV;
					}
					//对顶点 Y 轴进行旋转
					pos = mul(lastTransformMatrix, mul(rotateMatrix, mul(firstTransformMatrix, pos)));
					
					v[i] = GetVertex(pos, points[0].normal, uv);
				}

				......
			}

			......

			ENDCG
		}
    }
}
</code></pre>
<p>我们新增加一个<strong>属性 <em>_BladeForward</em> 来控制我们草的弯曲程度</strong>。在生成每个顶点之前，我们<strong>创建一个旋转矩阵来控制我们草在 Y 轴上的旋转，同时生成一个随机数影响草在 XZ 方向上进行偏移。</strong></p>
<p>现在我们再来看看效果。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggzy2kyaznj30g50dh0wh.jpg" alt="3_9.png" style="zoom:80%;" />
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh136dncdqj30on0dt7eu.jpg" alt="3_13.png" style="zoom:80%;" />
<p>可以看到现在草在 XZ 方向上产生了偏移，同时在 Y 轴方向上也产生了旋转，对比之前的更加生动了。</p>
<p>最后的部分到片元着色器，也就是实现草的光照部分。</p>
<pre><code class="language-cs">			//片元着色器
			//简单的 Blin-Phong 光照模型
			float4 frag(g2f i) : SV_Target{

				//对_MainTex纹理和_AlphaTex纹理进行采样
				fixed4 texColor = tex2D(_MainTex, i.uv);
				fixed alpha = tex2D(_AlphaTex, i.uv).a;

				//将法线归一化
				float3 worldNormal = normalize(i.normal);
				float3 worldSpecNormal = worldNormal;
				worldNormal = worldNormal * 0.5 + 0.5;

				//得到环境光
				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;
				//得到世界空间下光照方向
				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));

				//Diffuse 漫反射颜色
				fixed NdotL = saturate(dot(worldNormal, worldLightDir));
				fixed3 diffuse = _LightColor0.rgb * NdotL;

				//Specular 高光颜色
				//得到世界空间下的视线方向
				fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));
				//得到半角向量
				fixed3 halfDir = normalize(worldLightDir + worldViewDir);
				fixed3 NdotH = saturate(dot(worldSpecNormal, halfDir));
				float spec = pow(NdotH, _Specular * 128.0) * _Gloss;
				fixed3 specular = _SpecualarColor * _LightColor0.rgb * spec;

				//Fresnel
				fixed fresnel = saturate(1 - dot(worldSpecNormal, worldViewDir));
				//fresnel = clamp(fresnel - 0.2, 0, 1);
				fresnel = pow(fresnel, _FresnelPower) * clamp(i.uv.y - 0.5, 0, i.uv.y);
				fixed3 fresnelColor = fresnel * _FresnelColor * 2;

				//得到并输出最终颜色
				fixed3 finalColor = ambient + diffuse + specular + fresnelColor;
				return fixed4(texColor * _GrassColor.rgb * finalColor, alpha);
				//return fixed4(worldNormal, alpha);
			}
</code></pre>
<p>这里的部分比较简单，最终输出颜色的部分由<strong>环境光+漫反射+高光+边缘光相加</strong>组成。下面是最终的效果图。</p>
<blockquote>
<ul>
<li>
<p>ambient + diffuse</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh13ixlnjtj30oe0dxqcm.jpg" alt="3_14.png" style="zoom:80%;" />
</li>
<li>
<p>ambient + diffuse + specular</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh13lxeb5hj30of0duwoh.jpg" alt="3_15.png" style="zoom:80%;" />
</li>
<li>
<p>ambient + diffuse + specular + fresnelColor</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh13on89svj30ok0dr7fa.jpg" alt="3_16.png" style="zoom:80%;" />
</li>
</ul>
</blockquote>
<hr>
<h2 id="待优化">待优化</h2>
<p>到现在为止草的着色器已经基本完成了它的使命，最后想记录一下当时的几个想法和可以优化的空间。</p>
<p>第一个想法是在<strong>切线空间下生成每个草的法线</strong>。然后通过构造转换矩阵将切线空间下的法线转换到局部空间下，再进行后续的光照计算。当然，生成的法线同样需要经过旋转矩阵和 XZ 轴上的偏移。这样做的好处是<strong>可以让法线沿着每根草弯曲的方向偏移，使得每根草的光照更加精细</strong>。第二个想法是可以利用<strong>向量叉积的方法计算出每根草的法线</strong>。我们假设下面这张图是生成的草的网格。<strong>向量 AB 和向量 OC 进行叉积即可以得到垂直于这个面的向量（即法线）</strong>。当然，还要考虑到草的弯曲程度（<strong>即每个顶点的 XZ 偏移值</strong>），需要得到精确的草的法线的话应该还要计算每个单独面片的法线，再计算出平均值。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gh183ha94pj30k10klgmm.jpg" alt="3_17.png" style="zoom:50%;" />
<p>除了上述的思路之外，<strong>最后片元着色器的光照函数部分也有很大的优化空间。特别是其中的高光和边缘光部分</strong>。此外还有草的阴影以及草渲染中经常被提及的 Billboard 技术可以添加，就先留到后续思考吧。</p>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>Unity GeometryShader(从一个线框渲染的例子开始)</p>
<p><a href="https://www.cnblogs.com/Esfog/p/UnityGeometryShader_WireFrame.html">https://www.cnblogs.com/Esfog/p/UnityGeometryShader_WireFrame.html</a></p>
</li>
<li>
<p>Grass Shader</p>
<p><a href="https://roystan.net/articles/grass-shader.html">https://roystan.net/articles/grass-shader.html</a></p>
</li>
<li>
<p>My take on shaders: Geometry Shaders</p>
<p><a href="https://halisavakis.com/my-take-on-shaders-geometry-shaders/">https://halisavakis.com/my-take-on-shaders-geometry-shaders/</a></p>
</li>
<li>
<p>My take on shaders: Grass Shader (Part II)</p>
<p><a href="https://halisavakis.com/my-take-on-shaders-grass-shader-part-ii/">https://halisavakis.com/my-take-on-shaders-grass-shader-part-ii/</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity大片草地渲染2（草顶点集生成）]]></title>
        <id>https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-2cao-de-ding-dian-ji-sheng-cheng/</id>
        <link href="https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-2cao-de-ding-dian-ji-sheng-cheng/">
        </link>
        <updated>2020-07-19T10:58:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>上篇文章中我们制作了高低起伏的地形，这篇文章我们来生成草的顶点集。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggwha6qbi4j30o10cewj3.jpg" alt="Unity大片草迪渲染（地形生成）封面图.png" style="zoom:80%;" />
<hr>
<h2 id="思路图">思路图</h2>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggwhblju4gj30yu09rjs1.jpg" alt="2_8.png" style="zoom: 67%;" />
<hr>
<h2 id="正文">正文</h2>
<p>要想生成草的顶点集，首先要理解生成草的顶点集的原理是什么。<strong>顾名思义，草的顶点集就是我们要生成的每根草的顶点的集合（这个点确定了每根草在空间下的位置）</strong>，之后再利用我们的几何着色器（Geometry Shader）来进行草的生成（<strong>下一章讲解</strong>）。</p>
<blockquote>
<p>注意：我们的草需要添加材质，也就是我们后面由Geometry Shader生成的材质球。所以，<strong>我们需要创建一个新的网格（Mesh）来承载我们所有草的顶点集合</strong>。</p>
</blockquote>
<p>先上代码，代码承接上篇文章，有些许改动，<strong>这里只添加新的部分</strong>。</p>
<pre><code class="language-cs">    #Procedural Grass
    ......
        
    #region Grass Data
    [Range(0, 100)]
    public int grassRowCount = 50;          //草根集,定义草的广度
    [Range(1, 1000)]
    public int grassCountPerPatch = 100;          //定义每一堆 草根集 的草密度
    public Material grassMat;           //草的材质
	public Mesh grassMesh;          //草的网格
    List&lt;Vector3&gt; grassVerts = new List&lt;Vector3&gt;();          //存储草的顶点
    #endregion

    void Start()
    {
		......
            
        GenerateGrassArea(grassRowCount, grassCountPerPatch);
    }

	......

    //生成地形
    void GenerateTerrain()
    {
		......
            
        //清空grassVerts的数据    
        grassVerts.Clear();
    }

    //生成草的网格数据
    void GenerateGrassArea(int rowCount, int perPatchSize)
    {
        //最大顶点数为 65000
        List&lt;int&gt; indices = new List&lt;int&gt;();
        for (int i = 0; i &lt; 65000; i++)
        {
            indices.Add(i);
        }

        //初始位置
        Vector3 currentPos = transform.position;
        //草根集 每一次循环偏移的距离
        Vector3 patchSize = new Vector3(terrainSize / rowCount, 0, terrainSize / rowCount);

        //每一堆 草根集 进行循环
        for (int i = 0; i &lt; rowCount; i++)
        {
            for (int j = 0; j &lt; rowCount; j++)
            {
                GenerateGrass(currentPos, patchSize, grassCountPerPatch);
                currentPos.x += patchSize.x;
            }
            currentPos.x = transform.position.x;
            currentPos.z += patchSize.z;
        }

        //生成 GrassLayerGruop 来成为父级管理物理
        GameObject grassLayerGroup1 = new GameObject(&quot;GrassLayerGroup1&quot;);
        //生成 GrassLayer 物体来存储草数据
        GameObject grassLayer;
        MeshFilter grassMeshFilter;
        //Mesh grassMesh;
        MeshRenderer grassMeshRenderer;
        int a = 0;

        //当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
        //创立多个网格处理
        while (grassVerts.Count &gt; 65000)
        {
            grassMesh = new Mesh();
            grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();

            //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
            //每一个创建的网格的顶点数目不会超过 65000 个
            grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);

            //创建一个新的 GameObject 来承载这些点
            grassLayer = new GameObject(&quot;GrassLayer &quot; + a++);
            grassLayer.transform.SetParent(grassLayerGroup1.transform);
            grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
            grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
            //关闭草地的阴影投射和接受
            grassMeshRenderer.receiveShadows = false;
            grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
            grassMeshRenderer.sharedMaterial = grassMat;
            grassMeshFilter.mesh = grassMesh;
            //移除前 65000 个顶点
            grassVerts.RemoveRange(0, 65000);
        }

        //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时
        grassLayer = new GameObject(&quot;GrassLayer&quot; + a);
        grassLayer.transform.SetParent(grassLayerGroup1.transform);
        grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
        grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
        //关闭草地的阴影投射和接受
        grassMeshRenderer.receiveShadows = false;
        grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
        grassMesh = new Mesh();
        grassMesh.vertices = grassVerts.ToArray();
        //设立子网格数据
        grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);
        
        grassMeshFilter.mesh = grassMesh;
        grassMeshRenderer.sharedMaterial = grassMat;
    }

    //生成草
    void GenerateGrass(Vector3 vertPos, Vector3 patchSize, int grassCountPerPatch)
    {
        //每一堆 草根集 里的草进行循环
        for (int i = 0; i &lt; grassCountPerPatch; i++)
        {
            //Random.value 返回 0~1 之间的随机值
            //得到在两个 草根集 之间的草的随机位置并用索引值
            float randomX = Random.value * patchSize.x;
            float randomZ = Random.value * patchSize.z;

            int indexX = (int)((vertPos.x - transform.position.x) + randomX);
            int indexZ = (int)((vertPos.z - transform.position.z) + randomZ);

            //防止草种出地形
            if (indexX &gt;= terrainSize)
            {
                indexX = (int)terrainSize - 1;
            }

            if (indexZ &gt;= terrainSize)
            {
                indexZ = (int)terrainSize - 1;
            }

            //添加每一个草的顶点位置到 grassVert 列表里
            grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, vertPos.z + randomZ));
        }
    }
</code></pre>
<p>大部分代码都有结合注释。需要理解的是两个变量 <em>grassRowCount</em> 和 <em>grassCountPerPatch</em> 。其中，<strong><em>grassRowCount</em> 定义了在地形之中每一排，每一列有多少堆草，由 <em>grassRowCount</em> 得到的参数 <em>patchSize</em> 定义了每一堆草的广度；而 <em>grassCountPerPatch</em> 则是定义了每一堆草的密度。这三个参数变量可以控制我们整体草的范围和密度</strong>。我们创建了一个列表 <em>grassVerts</em> 存储全部草的顶点，并把这些顶点数据全部传给新创建的网格 <em>grassMesh</em> 中。（<em>grassRowCount</em> 和 <em>grassCountPerPatch</em> 参数可以结合下面的图片来理解）</p>
<blockquote>
<p>TerrainSize = TS</p>
<p>rowCount = 5</p>
<p>PatchSize = PS</p>
<p>grassCountPerPatch = GC （每一堆草的密度）</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gguwz70zg6j30ky0h93z3.jpg" alt="2_1.png" style="zoom:80%;" />
</blockquote>
<p>这里可以再具体看一下 <em>GenerateGrass</em> 函数内部。</p>
<pre><code class="language-cs">		//每一堆 草根集 里的草进行循环
        for (int i = 0; i &lt; grassCountPerPatch; i++)
        {
            //Random.value 返回 0~1 之间的随机值
            //得到在两个 草根集 之间的草的随机位置并用索引值
            float randomX = Random.value * patchSize.x;
            float randomZ = Random.value * patchSize.z;

            int indexX = (int)((vertPos.x - transform.position.x) + randomX);
            int indexZ = (int)((vertPos.z - transform.position.z) + randomZ);

            //防止草种出地形
            if (indexX &gt;= terrainSize)
            {
                indexX = (int)terrainSize - 1;
            }

            if (indexZ &gt;= terrainSize)
            {
                indexZ = (int)terrainSize - 1;
            }

            //添加每一个草的顶点位置到 grassVert 列表里
            grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, vertPos.z + randomZ));
        }
</code></pre>
<p>其中前半段是利用 <em>Random.value</em> 得到两个草堆之间每个草的随机位置，同时为了防止草种出草地需要进行相应的约束。<strong>注意最后一句：</strong></p>
<pre><code class="language-cs">			//添加每一个草的顶点位置到 grassVert 列表里
            grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, vertPos.z + randomZ));
</code></pre>
<p>还记得我们前面创建的 <em>grassVerts</em> 列表吗？这个列表存储的是 <em>Vector3</em> 类型（即每根草的位置）。<strong>为了与地形契合，我们需要借助前面生成地形时使用的 <em>perlinNoise</em> 数组，这个数组存储地形每个网格顶点的高度值，我们用 <em>indexX</em> 和 <em>indexZ</em> 两个参数作为索引，得到每根草对应的高度值</strong>。</p>
<p>得到下面的效果图，大片紫色是因为还没有赋予草材质，可以看到已经生成的大量的草的顶点。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gguxk3cj1hj30q30dvgwp.jpg" alt="2_2.png" style="zoom:80%;" />
<p>在上面的代码中，我们还在 <em>GenerateGrassArea</em> 函数中看到这样的一段代码：</p>
<pre><code class="language-cs">	//生成草的网格数据
    void GenerateGrassArea(int rowCount, int perPatchSize)
    {
        //最大顶点数为 65000
        List&lt;int&gt; indices = new List&lt;int&gt;();
        for (int i = 0; i &lt; 65000; i++)
        {
            indices.Add(i);
        }

        ......

        //当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
        //创立多个网格处理
        while (grassVerts.Count &gt; 65000)
        {
            grassMesh = new Mesh();
            grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();

            //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
            //每一个创建的网格的顶点数目不会超过 65000 个
            grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);

            ......
                
            //移除前 65000 个顶点
            grassVerts.RemoveRange(0, 65000);
        }

        //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时
		
        ......
            
        //设立子网格数据
        grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);
        
		......
    }                   
</code></pre>
<p>这一段代码是什么意思呢？这里需要先引入两个新的概念：</p>
<blockquote>
<ul>
<li><strong>网格拓补（MeshTopology）</strong></li>
<li><strong>子网格（SubMesh）</strong></li>
</ul>
</blockquote>
<p>在上一章中，我们讲到了构成网格（Mesh）的三角形结构。在Unity的官方文档关于**网格拓补（<em>MeshTopology</em>）**中有这样一段的解释：</p>
<blockquote>
<p><strong>通常，网格由三角形组成（每个面三个顶点索引），但是在某些情况下，您可能希望渲染由线或点组成的复杂事物。创建具有该拓扑的网格并使用它进行渲染通常是最有效的方法</strong>。</p>
</blockquote>
<p>是的，在本次项目中，我们在生成草的网格时，我们需要存储的仅仅是每根草的顶点而已，即我们生成的是一个<strong>由点组成的网格</strong>。而如何生成一个这样的网格Unity也说明了方法，就是用我们上面用到的 <strong>grass.SetIndices</strong> 方法。（下面是该方法的参数表格）</p>
<figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggv5syxrz9j30zs08975o.jpg" alt="2_3.png" loading="lazy"></figure>
<p>那什么是<strong>子网格（<em>SubMesh</em>）<strong>呢？在Unity中，我们往往会看到</strong>一个MeshRender（网格渲染器）可以有多个材质。这主要用于渲染具有多个独立三角形集的网格，称为子网格</strong>。</p>
<blockquote>
<p><strong>子网格属于网格的一部分，子网格所有的顶点数据都来自对应的网格。实际上子网格记录的是一串索引的数组，该数组可以取得对应的网格的网格信息，所有的子网格合在一起就可以渲染出完整的一个网格</strong>。</p>
</blockquote>
<p>那么子网格有什么用处呢？<strong>通常，我们导入进Unity的模型都会带有2~3甚至以上的材质，因为不用的材质对应模型不同的部位（在三维软件里可以区分网格），当我们将模型导出的时候，为了进行区分，每一个材质对应的顶点部分的所对应的网格组成一个子网格，即一种材质对应一个子网格。当然，如果一个模型只有一个材质，那么导出的子网格自然只有一个。</strong></p>
<p>了解完相应的概念后，我们来看回我们的代码。</p>
<p>我们在使用 <strong>SetIndices</strong> 方法创建子网格时要注意，我们需要一个索引列表来对网格的顶点数据进行索引，同时Unity里面规定，<strong>每一个子网格索引的顶点数目最多不能超过 65535 个。所以我们创建了一个容量为 65000 的列表 <em>Indices</em> 来进行索引，并将子网格分为两种，一种是顶点数目大于 65000 的，另一种是顶点数目小于 65000 的</strong>。</p>
<pre><code class="language-cs">		//最大顶点数为 65000
        List&lt;int&gt; indices = new List&lt;int&gt;();
        for (int i = 0; i &lt; 65000; i++)
        {
            indices.Add(i);
        }
</code></pre>
<p><strong>每一次索引都从 <em>grassVerts</em> 列表里面索引前 65000 个顶点组成一个单独的子网格，并在组成下一个子网格前移除 <em>grassVerts</em> 列表的前 65000 个顶点数据，并索引下一组数量为 65000 的顶点数据。当 <em>grassVerts</em> 列表的顶点数目不足 65000 时，便直接利用剩余的顶点组成子网格</strong>。</p>
<pre><code class="language-cs">		//当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
        //创立多个网格处理
        while (grassVerts.Count &gt; 65000)
        {
            grassMesh = new Mesh();
            grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();

            //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
            //每一个创建的网格的顶点数目不会超过 65000 个
            grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);
            ......       
            //移除前 65000 个顶点
            grassVerts.RemoveRange(0, 65000);
        }

        //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时	
        ......      
        //设立子网格数据
        grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);
</code></pre>
<p>最后共生成三个顶点数量为 65000 和一个顶点数量为 55000 的网格。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggv7hbwbftj30db0bpjs2.jpg" alt="2_4.png" style="zoom:80%;" />
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggv7hlxb6uj30dd0bnjrv.jpg" alt="2_5.png" style="zoom:80%;" />
<p>我们现在成功的生成了草的顶点集，并准备好下一步编写草的着色器了。</p>
<hr>
<h2 id="待优化">待优化</h2>
<p>文章中可以继续优化的地方还有很多。</p>
<p>第一个是<strong>草的光照问题</strong>（<strong>草的法线设置</strong>）。这个问题是在后面的步骤中遇到的，无论怎么样都无法达到理想的光照效果。在网上查阅资料时看到了一个很不错的思路，就是<strong>利用地形网格生成的法线来代替草的法线传入shader，这样既解决了光照的问题，又可以让草的光影效果和生成的地形一致</strong>。当然也可以直接在着色器里面生成草的法线。<strong>我们会在后面的文章中介绍到。</strong></p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggwgyickw4j30ng08oqg0.jpg" alt="2_6.png" style="zoom:80%;" />
<ul>
<li>
<p><strong>还原《塞尔达》的草地</strong></p>
</li>
<li>
<p>http://walkingfat.com/%E8%BF%98%E5%8E%9F%E3%80%8A%E5%A1%9E%E5%B0%94%E8%BE%BE%E3%80%8B%E7%9A%84%E8%8D%89%E5%9C%B0/</p>
</li>
</ul>
<p>第二个是<strong>草的优化问题</strong>。草的渲染中最容易想到的一个难题就是优化问题，特别是大片的草地渲染。在后期测试的时候，当草的数量上去的时候，<strong>需要处理的顶点数目过多，渲染的 <em>Drawcall</em> 过多导致画面十分的卡顿</strong>，无法正常运行。同时因为需要用到顶点动画来模拟风的运动，无法用Unity自带的批处理的方法来减少 <em>Drawcall</em>。在网上查阅到可以利用的一种很普遍的使用方法<strong>是使用Unity 提供的 GPU Instance 方式，使用 Graphics.DrawMeshInstanced 接口传入模型，材质，位置等信息，然后由GPU批量渲染</strong>。这种方法可以大大减少渲染的 <em>Drawcall</em> ，适用于大批渲染相同物体，网上同样也有很多的案例可以参考。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggwh40r8caj30o60f614j.jpg" alt="2_7.png" style="zoom:80%;" />
<ul>
<li>
<p><strong>Unity利用 GPUinstancing 实现大面积草地</strong></p>
</li>
<li>
<p>https://blog.csdn.net/qq_33967521/article/details/85139348</p>
</li>
</ul>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>【Unity Shader】使用Geometry Shader进行大片草地的实时渲染</p>
<p><a href="https://blog.csdn.net/weixin_44422550/article/details/105105351">https://blog.csdn.net/weixin_44422550/article/details/105105351</a></p>
</li>
<li>
<p>Unity 官方文档（Mesh.SetIndices）</p>
<p><a href="https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html">https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html</a></p>
</li>
<li>
<p>Unity 官方文档（MeshTopology）</p>
<p><a href="https://docs.unity3d.com/ScriptReference/MeshTopology.html">https://docs.unity3d.com/ScriptReference/MeshTopology.html</a></p>
</li>
<li>
<p>C# (CSharp) UnityEngine Mesh.SetIndices 示例</p>
<p><a href="https://csharp.hotexamples.com/zh/examples/UnityEngine/Mesh/SetIndices/php-mesh-setindices-method-examples.html">https://csharp.hotexamples.com/zh/examples/UnityEngine/Mesh/SetIndices/php-mesh-setindices-method-examples.html</a></p>
</li>
<li>
<p>Unity中Mesh和subMesh的区别</p>
<p><a href="https://blog.csdn.net/alexhu2010q/article/details/104935985">https://blog.csdn.net/alexhu2010q/article/details/104935985</a></p>
</li>
<li>
<p>Unity网格编程篇(二) 非常详细的Mesh编程入门文章</p>
<p><a href="https://blog.csdn.net/qq_29579137/article/details/77369734">https://blog.csdn.net/qq_29579137/article/details/77369734</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity大片草地渲染1（地形生成）]]></title>
        <id>https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-1di-xing-sheng-cheng/</id>
        <link href="https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-1di-xing-sheng-cheng/">
        </link>
        <updated>2020-07-17T07:53:44.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="前言">前言</h2>
<p>之前有个项目需要用到草地的渲染，很久之前就一直对Unity里面草地的渲染很感兴趣，但一直没有深入的了解。借着项目的缘由，我上网搜集并学习了很多关于Unity里面如何实现草地渲染的案例，期间也学习和整理了很多相关的知识。虽然最终没有完成全部目标，可以优化的地方也还有很多，但总归还是搭建了一个可以使用的雏形，我个人对最后的效果也还算比较满意。（下面是最终的效果图）</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gguba77j8rj30o00dhal8.jpg" alt="1_1.png" style="zoom:80%;" />
<p>现在回过头看当初整理的笔记，发现可以温习和提炼的知识点还是有挺多的。本着学习交流和回顾知识的初衷，决定根据自己的学习总结写下这几篇关于“Unity大片草地渲染”的系列文章。在这几篇文章中，将会从零开始介绍我当时一步步实现的流程，算是自己的学习经历，大概的知识点包括<strong>如何程序生成地形、利用几何着色器生成草、风的运动、草与玩家的交互以及一些草地光照的优化等，期间也会补充一些我当时去学习的基础但是很重要的知识点</strong>。本人也是仍在学习中的新手，许多经验和知识也都是通过搜索网络来学习整理得来，文章难免会有错误和疏漏，在分享之余也希望可以得到各位大佬的指点。<strong>同样，我也会将我自己当时参考的网站和资料贴在文章末尾，方便大家查阅和参考</strong>。</p>
<hr>
<h2 id="思路图">思路图</h2>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubbosiq4j30nx0hkq5s.jpg" alt="1_2.png" style="zoom:80%;" />
<hr>
<h2 id="正文">正文</h2>
<p>开始第一篇文章的正题。要想生成大片草地，首先需要一片地形。Unity地形的制作方法有很多种，例如</p>
<ul>
<li><strong>直接用Maya、Blender这样的建模软件制作并导出模型</strong></li>
<li><strong>用Unity自带的地形系统</strong></li>
<li><strong>直接利用高度图来生成高低起伏的网格地形</strong></li>
<li><strong>其他</strong></li>
</ul>
<p>而本次在项目中需要在地形上生成大量的顶点来生成每颗草的根部（即底部中心）。为了方便实现对地形以及草的各种参数的自定义，我们将使用程序生成的方法来控制地形的生成。</p>
<p><strong>要想知道如何生成地形网格，首先要了解Unity的网格（Mesh）是什么</strong>。无论是一个简单的基础Cube，还是一个复杂的粒子系统，或者一个复杂的人物模型和环境模型，在Unity里面都是由网格组成的。而所有的这些网格又都是由非常基础的元素组成的——点和线。</p>
<blockquote>
<p><strong>点，即一个顶点，顶点定义了一个在空间的位置。在一个空间里面有许多顶点（Vertices），在这些点之间绘制线，就组成了边缘（Edges），这些边缘创建了多边形面（Polygons），在Unity中为三角形（triangle），每三个顶点构成一个三角面。正是所有的这些三角形面组合起来定义了我们最终网格的形状。（结合下图来理解，图一来自网络，图二为Unity中Plane的网格）</strong></p>
</blockquote>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubckeqdsj30nk0cdadw.jpg" alt="1_3.png" style="zoom:80%;" />
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubcwlchbj30ag0act91.jpg" alt="1_4.png" style="zoom:80%;" />
<p>接下来看一下Unity怎样将网格渲染到屏幕上。为了渲染网格需要两个组件:</p>
<ul>
<li><strong>Mesh Filter</strong></li>
<li><strong>Mesh Renderer</strong></li>
</ul>
<blockquote>
<p><strong>其中，Mesh Filter存放物体的所有网格数据（顶点、三角形、UV等），而Mesh Renderer负责接收来自Mesh Filter的网格信息，并利用这些信息将网格渲染到屏幕上。同时，在Mesh Renderer中可以通过选择材质球、是否接受阴影等参数来决定网格如何被渲染到屏幕上。</strong></p>
</blockquote>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubdcx4kej30940c7q4g.jpg" alt="1_5.png" style="zoom:80%;" />
<p>了解完基础的网格知识后，在生成地形之前，先用代码生成一个网格平面。<strong>创建一个<em>ProceduralGrass</em>脚本，并挂载在一个空物体上。</strong></p>
<pre><code class="language-cs">#ProceduralGrass
[Range(0, 1000)]
public int terrainSize = 250;          //地形大小
public Material terrainMat;          //地形材质

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息

void Start()
{
    GenerateTerrain();
}

//生成地形网格数据
void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            vertexs.Add(new Vector3(i, 0, j));

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }
}

//生成地形
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();
    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh();
    //输入网格顶点数据
    groundMesh.vertices = vertexs.ToArray();
    //输入网格三角面数据
    groundMesh.triangles = triangles.ToArray();
    groundMesh.uv = uvs;
    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}
</code></pre>
<p><strong>大部分的代码都可以结合注释理解。其中在 <em>CreateVertsAndTris</em> 函数中</strong></p>
<pre><code class="language-cs">    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            vertexs.Add(new Vector3(i, 0, j));

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }
</code></pre>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubdztuipj30wr0ohdln.jpg" alt="1_6.png" style="zoom: 67%;" />
<p><strong>结合上图理解，vertexs列表按顺序存储网格的全部顶点的位置信息，而triangles列表存储的是构成每一个三角面的三个顶点的索引值（除位于坐标轴的顶点外，即图中的浅蓝色的顶点）</strong>。</p>
<blockquote>
<p><strong>需要特别注意的一点是注意triangles列表存储每三个顶点的顺序需要相同，如果方向不同的话就会出现法线不能正确计算导致出现问题。（如下图所示）</strong></p>
</blockquote>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubh2z2p2j30l90as79d.jpg" alt="1_7.png" style="zoom:80%;" />
<p>在 <em>GenrateTerrain</em> 函数中，<strong>除了网格的顶点和三角面数据外，还需要计算网格的UV和法线信息。</strong></p>
<pre><code class="language-cs">    //计算UV
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }
</code></pre>
<pre><code class="language-cs">    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
</code></pre>
<p>生成平面如下图所示：</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubhdv8ksj30kp0ah76v.jpg" alt="1_8.png" style="zoom:80%;" />
<p>接下来我们需要让这个平面有高低起伏，并能够控制地形的变化程度，我们继续修改代码。</p>
<pre><code class="language-cs">#ProceduralGrass
[Range(0, 1000)]
public int terrainSize = 250;          //地形大小
[Range(0, 100f)]
public float terrainHeight = 10f;          //地形高度 
public Material terrainMat;          //地形材质

[Range(1f, 100f)]
public float scaleFatter = 10f;          //地形缩放
[Range(1f, 100f)]
public float offsetFatter = 10f;          //地形偏移

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息
float[,] perlinNoise;          //存储每个顶点的高度值

void Start()
{
    perlinNoise = new float[terrainSize, terrainSize];
    GenerateTerrain();
}

//生成地形网格数据
void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            float noiseHeight = GeneratePerlinNoise(i, j);
            perlinNoise[i, j] = noiseHeight;

            vertexs.Add(new Vector3(i, noiseHeight * terrainHeight, j));

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }
}

//生成地形高度的随机 Perlin 值
float GeneratePerlinNoise(int i, int j)
{
    float xCoord = (float)i / terrainSize * scaleFatter + offsetFatter;
    float zCoord = (float)j / terrainSize * scaleFatter + offsetFatter;

    return Mathf.PerlinNoise(xCoord, zCoord);
}

//生成地形
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();
    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh();
    //输入网格顶点数据
    groundMesh.vertices = vertexs.ToArray();
    //输入网格三角面数据
    groundMesh.triangles = triangles.ToArray();
    groundMesh.uv = uvs;
    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}
</code></pre>
<p>在新增加的代码中利用 <em>Mathf.PerlinNosise</em> 函数生成每一个顶点的随机高度值。<strong>要注意，该函数接受两个float参数（在这里为顶点的索引值），同时两个参数的范围必须在0~1之间</strong>。<em>scaleFatter</em> 和 <em>offsetFatter</em> 分别控制 <em>PerlinNoise</em> 的缩放和偏移程度，改变两个参数可以控制地形的多样性和复杂程度。替换地形的材质，调节参数如下图所示。</p>
<blockquote>
<p>TerrianHeight = 10<br>
ScaleFatter = 10<br>
OffsetFatter = 10<br>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubhp6f81j30mf0bbn2s.jpg" alt="1_9.png" style="zoom: 67%;" /></p>
</blockquote>
<blockquote>
<p>TerrianHeight = 20<br>
ScaleFatter = 20<br>
OffsetFatter = 30<br>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubiemxfbj30mo0bldnh.jpg" alt="1_10.png" style="zoom:67%;" /></p>
</blockquote>
<p>最后就是生成连续的地形了。这里使用了一个较为简单和普遍的方法——<strong>利用多个小的地形网格组合生成连续的地形。要保证每个相邻的地形具有连续高度，首先要确保每个相邻地形的边界具有相同的高度值。这里我引入了两个变量 <em>xOffset</em> 和 <em>zOffset</em> 。</strong></p>
<pre><code class="language-cs">#ProceduralGrass
[Range(0, 1000)]
public int terrainSize = 250;          //地形大小
[Range(0, 100f)]
public float terrainHeight = 10f;          //地形高度 
public Material terrainMat;          //地形材质

private float xOffset;
private float zOffset;

[Range(1f, 100f)]
public float scaleFatter = 10f;          //地形缩放
[Range(1f, 100f)]
public float offsetFatter = 10f;          //地形偏移

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息
float[,] perlinNoise;          //存储每个顶点的高度值

void Start()
{
    xOffset = transform.position.x;
    zOffset = transform.position.z;

    perlinNoise = new float[terrainSize, terrainSize];
    GenerateTerrain();
}

//生成地形网格数据
void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            float noiseHeight = GeneratePerlinNoise(i, j);
            perlinNoise[i, j] = noiseHeight;

            vertexs.Add(new Vector3(i, noiseHeight * terrainHeight, j));

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }
}

//生成地形高度的随机 Perlin 值
float GeneratePerlinNoise(int i, int j)
{
    float xCoord = (float)(i + xOffset) / terrainSize * scaleFatter + offsetFatter;
    float zCoord = (float)(j + zOffset) / terrainSize * scaleFatter + offsetFatter;

    return Mathf.PerlinNoise(xCoord, zCoord);
}

//生成地形
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.transform.position = this.gameObject.transform.position;
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();
    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh();
    //输入网格顶点数据
    groundMesh.vertices = vertexs.ToArray();
    //输入网格三角面数据
    groundMesh.triangles = triangles.ToArray();
    groundMesh.uv = uvs;
    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}
</code></pre>
<p>创建多个空物体，分别将 <em>ProceduralGrass</em> 脚本拖到这些空物体下面。因为我这里设置的是 <em>TerrainSize = 250</em>，因此想要获得连续的地形，就需要改变空物体的位置。这里创建了三个空物体，并分别命名为Terrain0，Terrain1和Terrain2。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubiq2fjpj30n80lfadf.jpg" alt="1_11.png" style="zoom:80%;" />
<p><strong>最终的效果如图所示。</strong></p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubj1stnkj30o00ccaem.jpg" alt="1_12.png" style="zoom:80%;" />
<p>本篇文章就先写到这，到这一步已经完成了地形的创建，下一篇文章将介绍如何在地形网格上生成草的顶点集（即草的根部）。</p>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>Geometry in Unity</p>
<p><a href="https://learn.unity.com/tutorial/geometry-in-unity">https://learn.unity.com/tutorial/geometry-in-unity</a></p>
</li>
<li>
<p>【Unity Shader】使用Geometry Shader进行大片草地的实时渲染</p>
<p><a href="https://blog.csdn.net/weixin_44422550/article/details/105105351">https://blog.csdn.net/weixin_44422550/article/details/105105351</a></p>
</li>
<li>
<p>MESH GENERATION in Unity - Basics</p>
<p><a href="https://www.youtube.com/watch?v=eJEpeUH1EMg">https://www.youtube.com/watch?v=eJEpeUH1EMg</a></p>
</li>
<li>
<p>PROCEDURAL TERRAIN in Unity! - Mesh Generation</p>
<p><a href="https://www.youtube.com/watch?v=64NblGkAabk">https://www.youtube.com/watch?v=64NblGkAabk</a></p>
</li>
<li>
<p>Complete Guide to Procedural Level Generation in Unity – Part 1</p>
<p><a href="https://gamedevacademy.org/complete-guide-to-procedural-level-generation-in-unity-part-1/">https://gamedevacademy.org/complete-guide-to-procedural-level-generation-in-unity-part-1/</a></p>
</li>
</ul>
]]></content>
    </entry>
</feed>