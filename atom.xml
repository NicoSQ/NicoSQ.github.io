<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nicosq.github.io</id>
    <title>nicosq_Blog</title>
    <updated>2020-07-19T13:41:06.411Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nicosq.github.io"/>
    <link rel="self" href="https://nicosq.github.io/atom.xml"/>
    <subtitle>分享我的所学</subtitle>
    <logo>https://nicosq.github.io/images/avatar.png</logo>
    <icon>https://nicosq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, nicosq_Blog</rights>
    <entry>
        <title type="html"><![CDATA[Unity大片草地渲染2（草顶点集生成）]]></title>
        <id>https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-2cao-de-ding-dian-ji-sheng-cheng/</id>
        <link href="https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-2cao-de-ding-dian-ji-sheng-cheng/">
        </link>
        <updated>2020-07-19T10:58:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>上篇文章中我们制作了高低起伏的地形，这篇文章我们来生成草的顶点集。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggwha6qbi4j30o10cewj3.jpg" alt="Unity大片草迪渲染（地形生成）封面图.png" style="zoom:80%;" />
<hr>
<h2 id="思路图">思路图</h2>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggwhblju4gj30yu09rjs1.jpg" alt="2_8.png" style="zoom: 67%;" />
<hr>
<h2 id="正文">正文</h2>
<p>要想生成草的顶点集，首先要理解生成草的顶点集的原理是什么。<strong>顾名思义，草的顶点集就是我们要生成的每根草的顶点的集合（这个点确定了每根草在空间下的位置）</strong>，之后再利用我们的几何着色器（Geometry Shader）来进行草的生成（<strong>下一章讲解</strong>）。</p>
<blockquote>
<p>注意：我们的草需要添加材质，也就是我们后面由Geometry Shader生成的材质球。所以，<strong>我们需要创建一个新的网格（Mesh）来承载我们所有草的顶点集合</strong>。</p>
</blockquote>
<p>先上代码，代码承接上篇文章，有些许改动，<strong>这里只添加新的部分</strong>。</p>
<pre><code class="language-cs">    #Procedural Grass
    ......
        
    #region Grass Data
    [Range(0, 100)]
    public int grassRowCount = 50;          //草根集,定义草的广度
    [Range(1, 1000)]
    public int grassCountPerPatch = 100;          //定义每一堆 草根集 的草密度
    public Material grassMat;           //草的材质
	public Mesh grassMesh;          //草的网格
    List&lt;Vector3&gt; grassVerts = new List&lt;Vector3&gt;();          //存储草的顶点
    #endregion

    void Start()
    {
		......
            
        GenerateGrassArea(grassRowCount, grassCountPerPatch);
    }

	......

    //生成地形
    void GenerateTerrain()
    {
		......
            
        //清空grassVerts的数据    
        grassVerts.Clear();
    }

    //生成草的网格数据
    void GenerateGrassArea(int rowCount, int perPatchSize)
    {
        //最大顶点数为 65000
        List&lt;int&gt; indices = new List&lt;int&gt;();
        for (int i = 0; i &lt; 65000; i++)
        {
            indices.Add(i);
        }

        //初始位置
        Vector3 currentPos = transform.position;
        //草根集 每一次循环偏移的距离
        Vector3 patchSize = new Vector3(terrainSize / rowCount, 0, terrainSize / rowCount);

        //每一堆 草根集 进行循环
        for (int i = 0; i &lt; rowCount; i++)
        {
            for (int j = 0; j &lt; rowCount; j++)
            {
                GenerateGrass(currentPos, patchSize, grassCountPerPatch);
                currentPos.x += patchSize.x;
            }
            currentPos.x = transform.position.x;
            currentPos.z += patchSize.z;
        }

        //生成 GrassLayerGruop 来成为父级管理物理
        GameObject grassLayerGroup1 = new GameObject(&quot;GrassLayerGroup1&quot;);
        //生成 GrassLayer 物体来存储草数据
        GameObject grassLayer;
        MeshFilter grassMeshFilter;
        //Mesh grassMesh;
        MeshRenderer grassMeshRenderer;
        int a = 0;

        //当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
        //创立多个网格处理
        while (grassVerts.Count &gt; 65000)
        {
            grassMesh = new Mesh();
            grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();

            //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
            //每一个创建的网格的顶点数目不会超过 65000 个
            grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);

            //创建一个新的 GameObject 来承载这些点
            grassLayer = new GameObject(&quot;GrassLayer &quot; + a++);
            grassLayer.transform.SetParent(grassLayerGroup1.transform);
            grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
            grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
            //关闭草地的阴影投射和接受
            grassMeshRenderer.receiveShadows = false;
            grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
            grassMeshRenderer.sharedMaterial = grassMat;
            grassMeshFilter.mesh = grassMesh;
            //移除前 65000 个顶点
            grassVerts.RemoveRange(0, 65000);
        }

        //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时
        grassLayer = new GameObject(&quot;GrassLayer&quot; + a);
        grassLayer.transform.SetParent(grassLayerGroup1.transform);
        grassMeshFilter = grassLayer.AddComponent&lt;MeshFilter&gt;();
        grassMeshRenderer = grassLayer.AddComponent&lt;MeshRenderer&gt;();
        //关闭草地的阴影投射和接受
        grassMeshRenderer.receiveShadows = false;
        grassMeshRenderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
        grassMesh = new Mesh();
        grassMesh.vertices = grassVerts.ToArray();
        //设立子网格数据
        grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);
        
        grassMeshFilter.mesh = grassMesh;
        grassMeshRenderer.sharedMaterial = grassMat;
    }

    //生成草
    void GenerateGrass(Vector3 vertPos, Vector3 patchSize, int grassCountPerPatch)
    {
        //每一堆 草根集 里的草进行循环
        for (int i = 0; i &lt; grassCountPerPatch; i++)
        {
            //Random.value 返回 0~1 之间的随机值
            //得到在两个 草根集 之间的草的随机位置并用索引值
            float randomX = Random.value * patchSize.x;
            float randomZ = Random.value * patchSize.z;

            int indexX = (int)((vertPos.x - transform.position.x) + randomX);
            int indexZ = (int)((vertPos.z - transform.position.z) + randomZ);

            //防止草种出地形
            if (indexX &gt;= terrainSize)
            {
                indexX = (int)terrainSize - 1;
            }

            if (indexZ &gt;= terrainSize)
            {
                indexZ = (int)terrainSize - 1;
            }

            //添加每一个草的顶点位置到 grassVert 列表里
            grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, 								vertPos.z + randomZ));
        }
    }
</code></pre>
<p>大部分代码都有结合注释。需要理解的是两个变量 <em>grassRowCount</em> 和 <em>grassCountPerPatch</em> 。其中，<strong><em>grassRowCount</em> 定义了在地形之中每一排，每一列有多少堆草，由 <em>grassRowCount</em> 得到的参数 <em>patchSize</em> 定义了每一堆草的广度；而 <em>grassCountPerPatch</em> 则是定义了每一堆草的密度。这三个参数变量可以控制我们整体草的范围和密度</strong>。我们创建了一个列表 <em>grassVerts</em> 存储全部草的顶点，并把这些顶点数据全部传给新创建的网格 <em>grassMesh</em> 中。（<em>grassRowCount</em> 和 <em>grassCountPerPatch</em> 参数可以结合下面的图片来理解）</p>
<blockquote>
<p>TerrainSize = TS</p>
<p>rowCount = 5</p>
<p>PatchSize = PS</p>
<p>grassCountPerPatch = GC （每一堆草的密度）</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gguwz70zg6j30ky0h93z3.jpg" alt="2_1.png" style="zoom:80%;" />
</blockquote>
<p>这里可以再具体看一下 <em>GenerateGrass</em> 函数内部。</p>
<pre><code class="language-cs">		//每一堆 草根集 里的草进行循环
        for (int i = 0; i &lt; grassCountPerPatch; i++)
        {
            //Random.value 返回 0~1 之间的随机值
            //得到在两个 草根集 之间的草的随机位置并用索引值
            float randomX = Random.value * patchSize.x;
            float randomZ = Random.value * patchSize.z;

            int indexX = (int)((vertPos.x - transform.position.x) + randomX);
            int indexZ = (int)((vertPos.z - transform.position.z) + randomZ);

            //防止草种出地形
            if (indexX &gt;= terrainSize)
            {
                indexX = (int)terrainSize - 1;
            }

            if (indexZ &gt;= terrainSize)
            {
                indexZ = (int)terrainSize - 1;
            }

            //添加每一个草的顶点位置到 grassVert 列表里
            grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, 								vertPos.z + randomZ));
        }
</code></pre>
<p>其中前半段是利用 <em>Random.value</em> 得到两个草堆之间每个草的随机位置，同时为了防止草种出草地需要进行相应的约束。<strong>注意最后一句：</strong></p>
<pre><code class="language-cs">			//添加每一个草的顶点位置到 grassVert 列表里
            grassVerts.Add(new Vector3(vertPos.x + randomX, perlinNoise[indexX, indexZ] * terrainHeight, 								vertPos.z + randomZ));
</code></pre>
<p>还记得我们前面创建的 <em>grassVerts</em> 列表吗？这个列表存储的是 <em>Vector3</em> 类型（即每根草的位置）。<strong>为了与地形契合，我们需要借助前面生成地形时使用的 <em>perlinNoise</em> 数组，这个数组存储地形每个网格顶点的高度值，我们用 <em>indexX</em> 和 <em>indexZ</em> 两个参数作为索引，得到每根草对应的高度值</strong>。</p>
<p>得到下面的效果图，大片紫色是因为还没有赋予草材质，可以看到已经生成的大量的草的顶点。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gguxk3cj1hj30q30dvgwp.jpg" alt="2_2.png" style="zoom:80%;" />
<p>在上面的代码中，我们还在 <em>GenerateGrassArea</em> 函数中看到这样的一段代码：</p>
<pre><code class="language-cs">	//生成草的网格数据
    void GenerateGrassArea(int rowCount, int perPatchSize)
    {
        //最大顶点数为 65000
        List&lt;int&gt; indices = new List&lt;int&gt;();
        for (int i = 0; i &lt; 65000; i++)
        {
            indices.Add(i);
        }

        ......

        //当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
        //创立多个网格处理
        while (grassVerts.Count &gt; 65000)
        {
            grassMesh = new Mesh();
            grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();

            //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
            //每一个创建的网格的顶点数目不会超过 65000 个
            grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);

            ......
                
            //移除前 65000 个顶点
            grassVerts.RemoveRange(0, 65000);
        }

        //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时
		
        ......
            
        //设立子网格数据
        grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);
        
		......
    }                   
</code></pre>
<p>这一段代码是什么意思呢？这里需要先引入两个新的概念：</p>
<blockquote>
<ul>
<li><strong>网格拓补（MeshTopology）</strong></li>
<li><strong>子网格（SubMesh）</strong></li>
</ul>
</blockquote>
<p>在上一章中，我们讲到了构成网格（Mesh）的三角形结构。在Unity的官方文档关于**网格拓补（<em>MeshTopology</em>）**中有这样一段的解释：</p>
<blockquote>
<p><strong>通常，网格由三角形组成（每个面三个顶点索引），但是在某些情况下，您可能希望渲染由线或点组成的复杂事物。创建具有该拓扑的网格并使用它进行渲染通常是最有效的方法</strong>。</p>
</blockquote>
<p>是的，在本次项目中，我们在生成草的网格时，我们需要存储的仅仅是每根草的顶点而已，即我们生成的是一个<strong>由点组成的网格</strong>。而如何生成一个这样的网格Unity也说明了方法，就是用我们上面用到的 <strong>grass.SetIndices</strong> 方法。（下面是该方法的参数表格）</p>
<figure data-type="image" tabindex="1"><img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggv5syxrz9j30zs08975o.jpg" alt="2_3.png" loading="lazy"></figure>
<p>那什么是<strong>子网格（<em>SubMesh</em>）<strong>呢？在Unity中，我们往往会看到</strong>一个MeshRender（网格渲染器）可以有多个材质。这主要用于渲染具有多个独立三角形集的网格，称为子网格</strong>。</p>
<blockquote>
<p><strong>子网格属于网格的一部分，子网格所有的顶点数据都来自对应的网格。实际上子网格记录的是一串索引的数组，该数组可以取得对应的网格的网格信息，所有的子网格合在一起就可以渲染出完整的一个网格</strong>。</p>
</blockquote>
<p>那么子网格有什么用处呢？<strong>通常，我们导入进Unity的模型都会带有2~3甚至以上的材质，因为不用的材质对应模型不同的部位（在三维软件里可以区分网格），当我们将模型导出的时候，为了进行区分，每一个材质对应的顶点部分的所对应的网格组成一个子网格，即一种材质对应一个子网格。当然，如果一个模型只有一个材质，那么导出的子网格自然只有一个。</strong></p>
<p>了解完相应的概念后，我们来看回我们的代码。</p>
<p>我们在使用 <strong>SetIndices</strong> 方法创建子网格时要注意，我们需要一个索引列表来对网格的顶点数据进行索引，同时Unity里面规定，<strong>每一个子网格索引的顶点数目最多不能超过 65535 个。所以我们创建了一个容量为 65000 的列表 <em>Indices</em> 来进行索引，并将子网格分为两种，一种是顶点数目大于 65000 的，另一种是顶点数目小于 65000 的</strong>。</p>
<pre><code class="language-cs">		//最大顶点数为 65000
        List&lt;int&gt; indices = new List&lt;int&gt;();
        for (int i = 0; i &lt; 65000; i++)
        {
            indices.Add(i);
        }
</code></pre>
<p><strong>每一次索引都从 <em>grassVerts</em> 列表里面索引前 65000 个顶点组成一个单独的子网格，并在组成下一个子网格前移除 <em>grassVerts</em> 列表的前 65000 个顶点数据，并索引下一组数量为 65000 的顶点数据。当 <em>grassVerts</em> 列表的顶点数目不足 65000 时，便直接利用剩余的顶点组成子网格</strong>。</p>
<pre><code class="language-cs">		//当 grassVerts.Count 的数量即草的全部顶点数超过 65000 个时
        //创立多个网格处理
        while (grassVerts.Count &gt; 65000)
        {
            grassMesh = new Mesh();
            grassMesh.vertices = grassVerts.GetRange(0, 65000).ToArray();

            //设置子网格的索引缓冲区,相关官方文档：https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html
            //每一个创建的网格的顶点数目不会超过 65000 个
            grassMesh.SetIndices(indices.ToArray(), MeshTopology.Points, 0);
            ......       
            //移除前 65000 个顶点
            grassVerts.RemoveRange(0, 65000);
        }

        //当 grassVerts.Count 的数量即草的全部顶点数没有超过 65000 个时	
        ......      
        //设立子网格数据
        grassMesh.SetIndices(indices.GetRange(0, grassVerts.Count).ToArray(), MeshTopology.Points, 0);
</code></pre>
<p>最后共生成三个顶点数量为 65000 和一个顶点数量为 55000 的网格。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggv7hbwbftj30db0bpjs2.jpg" alt="2_4.png" style="zoom:80%;" />
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggv7hlxb6uj30dd0bnjrv.jpg" alt="2_5.png" style="zoom:80%;" />
<p>我们现在成功的生成了草的顶点集，并准备好下一步编写草的着色器了。</p>
<hr>
<h2 id="待优化">待优化</h2>
<p>文章中可以继续优化的地方还有很多，苦于本人水平有限，在经过多次查阅资料和尝试后依然没有成功，便先将问题和思路记录在此。</p>
<p>第一个是<strong>草的光照问题</strong>（<strong>草的法线设置</strong>）。这个问题是在后面的步骤中遇到的，无论怎么样都无法达到理想的光照效果。在网上查阅资料时看到了一个很不错的思路，就是<strong>利用地形网格生成的法线来代替草的法线传入shader，这样既解决了光照的问题，又可以让草的光影效果和生成的地形一致</strong>。当然也可以直接在着色器里面生成草的法线。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggwgyickw4j30ng08oqg0.jpg" alt="2_6.png" style="zoom:80%;" />
<ul>
<li>
<p><strong>还原《塞尔达》的草地</strong></p>
</li>
<li>
<p>http://walkingfat.com/%E8%BF%98%E5%8E%9F%E3%80%8A%E5%A1%9E%E5%B0%94%E8%BE%BE%E3%80%8B%E7%9A%84%E8%8D%89%E5%9C%B0/</p>
</li>
</ul>
<p>第二个是<strong>草的优化问题</strong>。草的渲染中最容易想到的一个难题就是优化问题，特别是大片的草地渲染。在后期测试的时候，当草的数量上去的时候，<strong>需要处理的顶点数目过多，渲染的 <em>Drawcall</em> 过多导致画面十分的卡顿</strong>，无法正常运行。同时因为需要用到顶点动画来模拟风的运动，无法用Unity自带的批处理的方法来减少 <em>Drawcall</em>。在网上查阅到可以利用的一种很普遍的使用方法<strong>是使用Unity 提供的 GPU Instance 方式，使用 Graphics.DrawMeshInstanced 接口传入模型，材质，位置等信息，然后由GPU批量渲染</strong>。这种方法可以大大减少渲染的 <em>Drawcall</em> ，适用于大批渲染相同物体，网上同样也有很多的案例可以参考。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggwh40r8caj30o60f614j.jpg" alt="2_7.png" style="zoom:80%;" />
<ul>
<li>
<p><strong>Unity利用 GPUinstancing 实现大面积草地</strong></p>
</li>
<li>
<p>https://blog.csdn.net/qq_33967521/article/details/85139348</p>
</li>
</ul>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>【Unity Shader】使用Geometry Shader进行大片草地的实时渲染</p>
<p>https://blog.csdn.net/weixin_44422550/article/details/105105351</p>
</li>
<li>
<p>Unity 官方文档（Mesh.SetIndices）</p>
<p>https://docs.unity3d.com/ScriptReference/Mesh.SetIndices.html</p>
</li>
<li>
<p>Unity 官方文档（MeshTopology）</p>
<p>https://docs.unity3d.com/ScriptReference/MeshTopology.html</p>
</li>
<li>
<p>C# (CSharp) UnityEngine Mesh.SetIndices 示例</p>
<p>https://csharp.hotexamples.com/zh/examples/UnityEngine/Mesh/SetIndices/php-mesh-setindices-method-examples.html</p>
</li>
<li>
<p>Unity中Mesh和subMesh的区别</p>
<p>https://blog.csdn.net/alexhu2010q/article/details/104935985</p>
</li>
<li>
<p>Unity网格编程篇(二) 非常详细的Mesh编程入门文章</p>
<p>https://blog.csdn.net/qq_29579137/article/details/77369734</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity大片草地渲染1（地形生成）]]></title>
        <id>https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-1di-xing-sheng-cheng/</id>
        <link href="https://nicosq.github.io/post/unity-da-pian-cao-di-xuan-ran-1di-xing-sheng-cheng/">
        </link>
        <updated>2020-07-17T07:53:44.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="前言">前言</h2>
<p>之前有个项目需要用到草地的渲染，很久之前就一直对Unity里面草地的渲染很感兴趣，但一直没有深入的了解。借着项目的缘由，我上网搜集并学习了很多关于Unity里面如何实现草地渲染的案例，期间也学习和整理了很多相关的知识。虽然最终没有完成全部目标，可以优化的地方也还有很多，但总归还是搭建了一个可以使用的雏形，我个人对最后的效果也还算比较满意。（下面是最终的效果图）</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1gguba77j8rj30o00dhal8.jpg" alt="1_1.png" style="zoom:80%;" />
<p>现在回过头看当初整理的笔记，发现可以温习和提炼的知识点还是有挺多的。本着学习交流和回顾知识的初衷，决定根据自己的学习总结写下这几篇关于“Unity大片草地渲染”的系列文章。在这几篇文章中，将会从零开始介绍我当时一步步实现的流程，算是自己的学习经历，大概的知识点包括<strong>如何程序生成地形、利用几何着色器生成草、风的运动、草与玩家的交互以及一些草地光照的优化等，期间也会补充一些我当时去学习的基础但是很重要的知识点</strong>。本人也是仍在学习中的新手，许多经验和知识也都是通过搜索网络来学习整理得来，文章难免会有错误和疏漏，在分享之余也希望可以得到各位大佬的指点。<strong>同样，我也会将我自己当时参考的网站和资料贴在文章末尾，方便大家查阅和参考</strong>。</p>
<hr>
<h2 id="思路图">思路图</h2>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubbosiq4j30nx0hkq5s.jpg" alt="1_2.png" style="zoom:80%;" />
<hr>
<h2 id="正文">正文</h2>
<p>开始第一篇文章的正题。要想生成大片草地，首先需要一片地形。Unity地形的制作方法有很多种，例如</p>
<ul>
<li><strong>直接用Maya、Blender这样的建模软件制作并导出模型</strong></li>
<li><strong>用Unity自带的地形系统</strong></li>
<li><strong>直接利用高度图来生成高低起伏的网格地形</strong></li>
<li><strong>其他</strong></li>
</ul>
<p>而本次在项目中需要在地形上生成大量的顶点来生成每颗草的根部（即底部中心）。为了方便实现对地形以及草的各种参数的自定义，我们将使用程序生成的方法来控制地形的生成。</p>
<p><strong>要想知道如何生成地形网格，首先要了解Unity的网格（Mesh）是什么</strong>。无论是一个简单的基础Cube，还是一个复杂的粒子系统，或者一个复杂的人物模型和环境模型，在Unity里面都是由网格组成的。而所有的这些网格又都是由非常基础的元素组成的——点和线。</p>
<blockquote>
<p><strong>点，即一个顶点，顶点定义了一个在空间的位置。在一个空间里面有许多顶点（Vertices），在这些点之间绘制线，就组成了边缘（Edges），这些边缘创建了多边形面（Polygons），在Unity中为三角形（triangle），每三个顶点构成一个三角面。正是所有的这些三角形面组合起来定义了我们最终网格的形状。（结合下图来理解，图一来自网络，图二为Unity中Plane的网格）</strong></p>
</blockquote>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubckeqdsj30nk0cdadw.jpg" alt="1_3.png" style="zoom:80%;" />
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubcwlchbj30ag0act91.jpg" alt="1_4.png" style="zoom:80%;" />
<p>接下来看一下Unity怎样将网格渲染到屏幕上。为了渲染网格需要两个组件:</p>
<ul>
<li><strong>Mesh Filter</strong></li>
<li><strong>Mesh Renderer</strong></li>
</ul>
<blockquote>
<p><strong>其中，Mesh Filter存放物体的所有网格数据（顶点、三角形、UV等），而Mesh Renderer负责接收来自Mesh Filter的网格信息，并利用这些信息将网格渲染到屏幕上。同时，在Mesh Renderer中可以通过选择材质球、是否接受阴影等参数来决定网格如何被渲染到屏幕上。</strong></p>
</blockquote>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubdcx4kej30940c7q4g.jpg" alt="1_5.png" style="zoom:80%;" />
<p>了解完基础的网格知识后，在生成地形之前，先用代码生成一个网格平面。<strong>创建一个<em>ProceduralGrass</em>脚本，并挂载在一个空物体上。</strong></p>
<pre><code class="language-cs">#ProceduralGrass
[Range(0, 1000)]
public int terrainSize = 250;          //地形大小
public Material terrainMat;          //地形材质

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息

void Start()
{
    GenerateTerrain();
}

//生成地形网格数据
void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            vertexs.Add(new Vector3(i, 0, j));

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }
}

//生成地形
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();
    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh();
    //输入网格顶点数据
    groundMesh.vertices = vertexs.ToArray();
    //输入网格三角面数据
    groundMesh.triangles = triangles.ToArray();
    groundMesh.uv = uvs;
    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}
</code></pre>
<p><strong>大部分的代码都可以结合注释理解。其中在 <em>CreateVertsAndTris</em> 函数中</strong></p>
<pre><code class="language-cs">    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            vertexs.Add(new Vector3(i, 0, j));

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }
</code></pre>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubdztuipj30wr0ohdln.jpg" alt="1_6.png" style="zoom: 67%;" />
<p><strong>结合上图理解，vertexs列表按顺序存储网格的全部顶点的位置信息，而triangles列表存储的是构成每一个三角面的三个顶点的索引值（除位于坐标轴的顶点外，即图中的浅蓝色的顶点）</strong>。</p>
<blockquote>
<p><strong>需要特别注意的一点是注意triangles列表存储每三个顶点的顺序需要相同，如果方向不同的话就会出现法线不能正确计算导致出现问题。（如下图所示）</strong></p>
</blockquote>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubh2z2p2j30l90as79d.jpg" alt="1_7.png" style="zoom:80%;" />
<p>在 <em>GenrateTerrain</em> 函数中，<strong>除了网格的顶点和三角面数据外，还需要计算网格的UV和法线信息。</strong></p>
<pre><code class="language-cs">    //计算UV
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }
</code></pre>
<pre><code class="language-cs">    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
</code></pre>
<p>生成平面如下图所示：</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubhdv8ksj30kp0ah76v.jpg" alt="1_8.png" style="zoom:80%;" />
<p>接下来我们需要让这个平面有高低起伏，并能够控制地形的变化程度，我们继续修改代码。</p>
<pre><code class="language-cs">#ProceduralGrass
[Range(0, 1000)]
public int terrainSize = 250;          //地形大小
[Range(0, 100f)]
public float terrainHeight = 10f;          //地形高度 
public Material terrainMat;          //地形材质

[Range(1f, 100f)]
public float scaleFatter = 10f;          //地形缩放
[Range(1f, 100f)]
public float offsetFatter = 10f;          //地形偏移

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息
float[,] perlinNoise;          //存储每个顶点的高度值

void Start()
{
    perlinNoise = new float[terrainSize, terrainSize];
    GenerateTerrain();
}

//生成地形网格数据
void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            float noiseHeight = GeneratePerlinNoise(i, j);
            perlinNoise[i, j] = noiseHeight;

            vertexs.Add(new Vector3(i, noiseHeight * terrainHeight, j));

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }
}

//生成地形高度的随机 Perlin 值
float GeneratePerlinNoise(int i, int j)
{
    float xCoord = (float)i / terrainSize * scaleFatter + offsetFatter;
    float zCoord = (float)j / terrainSize * scaleFatter + offsetFatter;

    return Mathf.PerlinNoise(xCoord, zCoord);
}

//生成地形
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();
    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh();
    //输入网格顶点数据
    groundMesh.vertices = vertexs.ToArray();
    //输入网格三角面数据
    groundMesh.triangles = triangles.ToArray();
    groundMesh.uv = uvs;
    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}
</code></pre>
<p>在新增加的代码中利用 <em>Mathf.PerlinNosise</em> 函数生成每一个顶点的随机高度值。<strong>要注意，该函数接受两个float参数（在这里为顶点的索引值），同时两个参数的范围必须在0~1之间</strong>。<em>scaleFatter</em> 和 <em>offsetFatter</em> 分别控制 <em>PerlinNoise</em> 的缩放和偏移程度，改变两个参数可以控制地形的多样性和复杂程度。替换地形的材质，调节参数如下图所示。</p>
<blockquote>
<p>TerrianHeight = 10<br>
ScaleFatter = 10<br>
OffsetFatter = 10<br>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubhp6f81j30mf0bbn2s.jpg" alt="1_9.png" style="zoom: 67%;" /></p>
</blockquote>
<blockquote>
<p>TerrianHeight = 20<br>
ScaleFatter = 20<br>
OffsetFatter = 30<br>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubiemxfbj30mo0bldnh.jpg" alt="1_10.png" style="zoom:67%;" /></p>
</blockquote>
<p>最后就是生成连续的地形了。这里使用了一个较为简单和普遍的方法——<strong>利用多个小的地形网格组合生成连续的地形。要保证每个相邻的地形具有连续高度，首先要确保每个相邻地形的边界具有相同的高度值。这里我引入了两个变量 <em>xOffset</em> 和 <em>zOffset</em> 。</strong></p>
<pre><code class="language-cs">#ProceduralGrass
[Range(0, 1000)]
public int terrainSize = 250;          //地形大小
[Range(0, 100f)]
public float terrainHeight = 10f;          //地形高度 
public Material terrainMat;          //地形材质

private float xOffset;
private float zOffset;

[Range(1f, 100f)]
public float scaleFatter = 10f;          //地形缩放
[Range(1f, 100f)]
public float offsetFatter = 10f;          //地形偏移

List&lt;Vector3&gt; vertexs = new List&lt;Vector3&gt;();          //顶点列表，存储网格顶点信息
List&lt;int&gt; triangles = new List&lt;int&gt;();          //三角形面列表，存储网格三角形信息
float[,] perlinNoise;          //存储每个顶点的高度值

void Start()
{
    xOffset = transform.position.x;
    zOffset = transform.position.z;

    perlinNoise = new float[terrainSize, terrainSize];
    GenerateTerrain();
}

//生成地形网格数据
void CreateVertsAndTris()
{
    //遍历每一个顶点，并用列表 vertexs 和 triangles 存储
    for (int i = 0; i &lt; terrainSize; i++)
    {
        for (int j = 0; j &lt; terrainSize; j++)
        {
            float noiseHeight = GeneratePerlinNoise(i, j);
            perlinNoise[i, j] = noiseHeight;

            vertexs.Add(new Vector3(i, noiseHeight * terrainHeight, j));

            //不算上坐标轴的顶点
            if (i == 0 || j == 0)
                continue;

            //每三个顶点作为一个索引建立三角形
            triangles.Add(terrainSize * i + j);
            triangles.Add(terrainSize * i + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j - 1);
            triangles.Add(terrainSize * (i - 1) + j);
            triangles.Add(terrainSize * i + j);
        }
    }
}

//生成地形高度的随机 Perlin 值
float GeneratePerlinNoise(int i, int j)
{
    float xCoord = (float)(i + xOffset) / terrainSize * scaleFatter + offsetFatter;
    float zCoord = (float)(j + zOffset) / terrainSize * scaleFatter + offsetFatter;

    return Mathf.PerlinNoise(xCoord, zCoord);
}

//生成地形
void GenerateTerrain()
{
    CreateVertsAndTris();

    //计算UV
    Vector2[] uvs = new Vector2[vertexs.Count];
    for (int i = 0; i &lt; vertexs.Count; i++)
    {
        uvs[i] = new Vector2(vertexs[i].x, vertexs[i].z);
    }

    //添加一个 MyTerrain 的物体，并添加 MeshFilter / MeshRenderer 两个组件
    //MeshFilter 存储物体的网格信息
    //MeshRenderer 负责接收这些信息并把这些信息渲染出来
    GameObject Myterrain = new GameObject(&quot;Terrain0&quot;);
    Myterrain.transform.position = this.gameObject.transform.position;
    Myterrain.AddComponent&lt;MeshFilter&gt;();
    MeshRenderer renderer = Myterrain.AddComponent&lt;MeshRenderer&gt;();
    //开启地面的阴影投射和接受
    renderer.receiveShadows = true;
    renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
    //添加Mesh Collider
    MeshCollider collider = Myterrain.AddComponent&lt;MeshCollider&gt;();
    //添加材质
    renderer.sharedMaterial = terrainMat;

    //创建一个 Mesh 网格
    Mesh groundMesh = new Mesh();
    //输入网格顶点数据
    groundMesh.vertices = vertexs.ToArray();
    //输入网格三角面数据
    groundMesh.triangles = triangles.ToArray();
    groundMesh.uv = uvs;
    //为了得到正确的光照需要重新计算得到正确的法线信息
    groundMesh.RecalculateNormals();
    Myterrain.GetComponent&lt;MeshFilter&gt;().mesh = groundMesh;
    collider.sharedMesh = groundMesh;
}
</code></pre>
<p>创建多个空物体，分别将 <em>ProceduralGrass</em> 脚本拖到这些空物体下面。因为我这里设置的是 <em>TerrainSize = 250</em>，因此想要获得连续的地形，就需要改变空物体的位置。这里创建了三个空物体，并分别命名为Terrain0，Terrain1和Terrain2。</p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubiq2fjpj30n80lfadf.jpg" alt="1_11.png" style="zoom:80%;" />
<p><strong>最终的效果如图所示。</strong></p>
<img src="http://ww1.sinaimg.cn/large/0073Nbi8gy1ggubj1stnkj30o00ccaem.jpg" alt="1_12.png" style="zoom:80%;" />
<p>本篇文章就先写到这，到这一步已经完成了地形的创建，下一篇文章将介绍如何在地形网格上生成草的顶点集（即草的根部）。</p>
<hr>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>Geometry in Unity</p>
<p><a href="https://learn.unity.com/tutorial/geometry-in-unity">https://learn.unity.com/tutorial/geometry-in-unity</a></p>
</li>
<li>
<p>【Unity Shader】使用Geometry Shader进行大片草地的实时渲染</p>
<p><a href="https://blog.csdn.net/weixin_44422550/article/details/105105351">https://blog.csdn.net/weixin_44422550/article/details/105105351</a></p>
</li>
<li>
<p>MESH GENERATION in Unity - Basics</p>
<p><a href="https://www.youtube.com/watch?v=eJEpeUH1EMg">https://www.youtube.com/watch?v=eJEpeUH1EMg</a></p>
</li>
<li>
<p>PROCEDURAL TERRAIN in Unity! - Mesh Generation</p>
<p><a href="https://www.youtube.com/watch?v=64NblGkAabk">https://www.youtube.com/watch?v=64NblGkAabk</a></p>
</li>
<li>
<p>Complete Guide to Procedural Level Generation in Unity – Part 1</p>
<p><a href="https://gamedevacademy.org/complete-guide-to-procedural-level-generation-in-unity-part-1/">https://gamedevacademy.org/complete-guide-to-procedural-level-generation-in-unity-part-1/</a></p>
</li>
</ul>
]]></content>
    </entry>
</feed>